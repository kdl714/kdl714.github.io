<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flexible JSON Filter — Simple UI</title>
<style>
  :root{--bg:#0b0b10;--panel:#131320;--muted:#9aa0ac;--text:#e9e9f1;--accent:#5b8cff;--stroke:#202036;--field:#0f0f19;--ok:#2ecc71;--err:#ff5c5c}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:32px auto;padding:0 16px}
  .card{background:var(--panel);border:1px solid var(--stroke);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
  header{padding:18px;border-bottom:1px solid var(--stroke);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  header h1{margin:0;font-size:18px}
  header .sub{color:var(--muted);font-size:13px}
  .content{display:grid;grid-template-columns:1fr 1fr;gap:18px;padding:18px}
  .content.single{grid-template-columns:1fr}
  @media(max-width:980px){.content{grid-template-columns:1fr}}
  .section{display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:13px;color:var(--muted)}
  textarea,input[type=text],select{width:100%;padding:12px;border-radius:12px;border:1px solid var(--stroke);background:var(--field);color:var(--text)}
  textarea{min-height:220px;resize:vertical}
  input[type=file]{font-size:13px;max-width:100%}
  .btn{appearance:none;border:none;padding:10px 14px;border-radius:12px;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
  .btn.secondary{background:#2a2a44;color:#d9d9e6}
  .btn.ghost{background:transparent;border:1px solid var(--stroke);color:var(--text)}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .hint{font-size:12px;color:var(--muted)}
  .status{font-size:13px;margin-top:6px}
  .status.ok{color:var(--ok)} .status.err{color:var(--err);white-space:pre-wrap}
  .group{border:1px solid var(--stroke);border-radius:12px;padding:12px;background:#0f0f19}
  .group h3{margin:0 0 8px 0;font-size:13px;color:#bdbdd3}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media(max-width:980px){.two{grid-template-columns:1fr}}
  .listbox{width:100%;min-height:220px;max-height:260px;overflow:auto;padding:0;margin:0;border:1px solid #1e1e33;border-radius:10px;background:#0c0c16}
  .listbox option{padding:10px 12px;border-bottom:1px solid #17172a}
  .pathhint{font-family:ui-monospace,Consolas,Menlo,monospace;color:#bdbdd3}
  .chiplist{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:8px;max-height:240px;overflow:auto;padding:8px;background:#0c0c16;border:1px solid #1e1e33;border-radius:10px}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:10px;background:#101022;border:1px solid #232345;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:13px;color:#d6d6e6}
  table{width:100%;border-collapse:separate;border-spacing:0;background:var(--field);border:1px solid var(--stroke);border-radius:12px;overflow:hidden}
  th,td{padding:10px 12px;border-bottom:1px solid #1e1e30;text-align:left;vertical-align:top}
  th{background:#101022;font-size:12px;color:#bdbdd3;position:sticky;top:0}
  tr:last-child td{border-bottom:none}
  .footer{padding:12px 18px;border-top:1px solid var(--stroke);display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between}
  code.bubble{background:#101022;padding:2px 6px;border-radius:8px;border:1px solid #232345;font-family:ui-monospace,Consolas,Menlo,monospace}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <h1>Flexible JSON Filter</h1>
      <div class="sub">No installs • local only • no defaults</div>
    </header>

    <div class="content">
      <!-- LOAD -->
      <div class="section">
        <label>1) Load JSON (choose one):</label>
        <div class="row">
          <input id="fileInput" type="file" accept=".json,application/json"/>
          <button class="btn ghost" id="clearBtn">Clear</button>
        </div>
        <textarea id="jsonText" placeholder="Paste any JSON (object or array)"></textarea>
        <div class="hint">File picker is faster for very large files.</div>
      </div>

      <!-- BUILDER -->
      <div class="section">
        <label>2) Build your query (filter + outputs)</label>

        <div class="group">
          <h3>Filter field</h3>
          <div class="two">
            <input id="fieldSearch" type="text" placeholder="Search fields… e.g. account_name, email, id">
            <label class="row" style="gap:8px;"><input id="showPaths" type="checkbox"> <span class="hint">Show full JSON paths</span></label>
          </div>
          <select id="fieldList" size="10" class="listbox" title="Pick a field to filter"></select>
          <div class="two">
            <input id="valuesInput" type="text" placeholder="Values (comma-separated)">
            <div class="row">
              <label><input id="caseInsensitive" type="checkbox"> Case-insensitive</label>
              <label><input id="exactMatch" type="checkbox"> Exact match</label>
            </div>
          </div>
          <div class="hint">Items are shown as <code class="bubble">collection.chain.field</code> with a sample value.</div>
        </div>

        <div class="group">
          <h3>Row mode</h3>
          <div class="row">
            <label><input type="radio" name="rowmode" id="modeMatch"> Per match (flatten)</label>
            <label><input type="radio" name="rowmode" id="modeParent"> Per parent (aggregate)</label>
          </div>
          <div class="hint">No ancestor dropdown. “Parent” = the nearest list ancestor of the matching item (e.g. the user above their role_members).</div>
        </div>

        <div class="group">
          <h3>Output fields</h3>
          <div class="row"><strong>Row fields</strong> <button class="btn ghost" id="rowAll">All</button><button class="btn ghost" id="rowNone">None</button></div>
          <div id="rowFieldGrid" class="chiplist"></div>
          <div class="row" style="margin-top:8px;"><strong>Matched item fields</strong> <span class="hint">(only if filtering inside a nested list)</span> <button class="btn ghost" id="matchAll">All</button><button class="btn ghost" id="matchNone">None</button></div>
          <div id="matchFieldGrid" class="chiplist"></div>
        </div>

        <div class="row" style="gap:10px;">
          <button class="btn" id="runBtn" disabled>Run</button>
          <button class="btn secondary" id="downloadJsonBtn" disabled>Download JSON</button>
          <button class="btn secondary" id="downloadCsvBtn" disabled>Download CSV</button>
          <button class="btn ghost" id="copyBtn" disabled>Copy JSON</button>
        </div>
        <div id="status" class="status"></div>
      </div>
    </div>

    <!-- RESULTS -->
    <div class="content single">
      <div class="section">
        <label>Results</label>
        <div style="overflow:auto;max-height:55vh;border-radius:12px">
          <table id="resultsTable" style="display:none;">
            <thead><tr id="theadRow"></tr></thead>
            <tbody id="resultsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="footer">
      <span class="hint">Everything runs locally in your browser.</span>
      <span class="hint">Want wildcard search later? Easy to add.</span>
    </div>
  </div>
</div>

<script>
(function(){
  // DOM refs
  const fileInput=document.getElementById('fileInput'), jsonText=document.getElementById('jsonText'), clearBtn=document.getElementById('clearBtn');
  const fieldSearch=document.getElementById('fieldSearch'), showPaths=document.getElementById('showPaths'), fieldList=document.getElementById('fieldList');
  const valuesInput=document.getElementById('valuesInput'), caseInsensitive=document.getElementById('caseInsensitive'), exactMatch=document.getElementById('exactMatch');
  const modeMatch=document.getElementById('modeMatch'), modeParent=document.getElementById('modeParent');
  const rowFieldGrid=document.getElementById('rowFieldGrid'), matchFieldGrid=document.getElementById('matchFieldGrid');
  const rowAll=document.getElementById('rowAll'), rowNone=document.getElementById('rowNone'), matchAll=document.getElementById('matchAll'), matchNone=document.getElementById('matchNone');
  const runBtn=document.getElementById('runBtn'), statusEl=document.getElementById('status'), resultsTable=document.getElementById('resultsTable'), theadRow=document.getElementById('theadRow'), resultsBody=document.getElementById('resultsBody');
  const downloadJsonBtn=document.getElementById('downloadJsonBtn'), downloadCsvBtn=document.getElementById('downloadCsvBtn'), copyBtn=document.getElementById('copyBtn');

  // State
  let root=null;
  let fieldEntries=[]; // [{label, path, sample, holderPath, listAncestors: ['$.users[]','$.users[].role_members[]'], chainLabel: 'users.role_members.account_name', holderName:'role_members', parentName:'users'}]
  let filteredEntries=[];
  let selectedField=null;
  let selectedRowFields=new Set();
  let selectedMatchFields=new Set();
  let lastRows=[], lastCols=[];

  // Utils
  const esc=v=>String(v??'').replace(/[&<>"']/g,s=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
  const setStatus=(m,k)=>{statusEl.textContent=m||'';statusEl.className='status '+(k||'')}
  const setDownloads=on=>{downloadJsonBtn.disabled=downloadCsvBtn.disabled=copyBtn.disabled=!on}
  const parseVals=(s,ci)=>new Set((s||'').split(',').map(x=>x.trim()).filter(Boolean).map(x=>ci?x.toLowerCase():x));
  const matchAllowed=(allowed,val,{ci,exact})=>{const t=ci?String(val??'').toLowerCase():String(val??'');if(exact)return allowed.has(t);for(const a of allowed)if(t.includes(a))return true;return false;}
  const enableRun=()=>{runBtn.disabled=!(root && selectedField && valuesInput.value.trim() && (modeMatch.checked||modeParent.checked));}

  // Token helpers
  const isColl = tok => /\[\]|\[\*\]$/.test(tok);
  const base = tok => tok.replace(/\[\]|\[\*\]/,'');
  const tokensOf = path => path.split('.');

  // Scan all scalar fields + context (friendly labels)
  function scanFields(root){
    const out=[];
    function walk(node, toks, listAnc){
      if (node==null) return;
      if (Array.isArray(node)){
        for(const el of node) walk(el, toks, toks.length? (isColl(toks[toks.length-1])? listAnc.concat([toks.join('.')]) : listAnc) : listAnc);
      } else if (typeof node==='object'){
        const parentTok=toks[toks.length-1]||'$';
        const newListAnc = isColl(parentTok)? listAnc.concat([toks.join('.')]) : listAnc;
        for(const [k,v] of Object.entries(node)){
          const tok=(isColl(parentTok)? base(parentTok):parentTok)==='$' ? '$.'+k : k;
          const next = toks.length? toks.concat([k]) : ['$.',k];
          if (v && typeof v==='object'){
            if (Array.isArray(v)){
              walk(v, [...next.slice(0,-1), next[next.length-1]+'[]'], newListAnc);
            } else {
              walk(v, next, newListAnc);
            }
          } else {
            // scalar
            const holderPath = toks.join('.');
            const holderName = base(tokensOf(holderPath).slice(-1)[0]||'');
            const chain = [...newListAnc.map(p=>base(tokensOf(p).slice(-1)[0]||'')), holderName].filter(Boolean).join('.');
            const chainLabel = (chain? chain+'.':'') + k;
            const parentName = base(tokensOf(newListAnc.slice(-1)[0]||'')[0]||'') || base(tokensOf(newListAnc.slice(-1)[0]||'').slice(-1)[0]||'');
            out.push({ path: (toks.length? toks.join('.')+'.':'$.' )+k, sample:v, holderPath, listAncestors:newListAnc, chainLabel, holderName, parentName });
          }
        }
      }
    }
    walk(root, ['$'], []);
    // dedupe by path
    const seen=new Set(); return out.filter(e=>{if(seen.has(e.path))return false; seen.add(e.path); return true;});
  }

  // Build list UI
  function renderFieldList(){
    fieldList.innerHTML='';
    filteredEntries.forEach(e=>{
      const text = showPaths.checked ? `${e.chainLabel} • ${e.path} — sample: ${String(e.sample).slice(0,80)}`
                                     : `${e.chainLabel} — sample: ${String(e.sample).slice(0,80)}`;
      const opt=document.createElement('option'); opt.value=e.path; opt.textContent=text; fieldList.appendChild(opt);
    });
  }

  // Resolve matches for selected field
  function resolveMatches(fieldPath){
    const tks=tokensOf(fieldPath);
    const res=[];
    function recur(node, idx, listStack, objStack){
      if (idx>=tks.length) return;
      const tok=tks[idx];
      if (tok==='$'||tok==='$.'){recur(node, idx+1, listStack, objStack); return;}
      const coll=isColl(tok), key=base(tok);
      if (coll){
        const seq=node?.[key];
        const items = Array.isArray(seq)? seq : (seq && typeof seq==='object'? Object.values(seq) : []);
        for(const el of items){
          if (el && typeof el==='object') recur(el, idx+1, listStack.concat([{path:tks.slice(0,idx+1).join('.'), name:key, obj:el}]), objStack);
        }
      } else {
        if (idx===tks.length-1){
          const holder=node;
          const v=holder?.[key];
          if (v!==undefined && (typeof v!=='object' || v===null)){
            res.push({ value:v, holder, listStack, objStack });
          }
        } else {
          const nxt=node?.[key];
          if (nxt && typeof nxt==='object') recur(nxt, idx+1, listStack, objStack.concat([{path:tks.slice(0,idx+1).join('.'), name:key, obj:nxt}]));
        }
      }
    }
    recur(root,0,[],[]);
    return res;
  }

  // Find parent object (nearest list ancestor)
  function nearestParent(match){
    const ls=match.listStack;
    if (!ls.length) return match.holder; // top-level field inside row
    return ls[ls.length-1].obj;
  }

  // Detect scalar keys for objects (row/match)
  function detectScalarKeys(objs){
    const set=new Set();
    const n=Math.min(50,objs.length);
    for(let i=0;i<n;i++){
      const o=objs[i];
      if (!o || typeof o!=='object') continue;
      for(const [k,v] of Object.entries(o)) if (v==null || typeof v!=='object') set.add(k);
    }
    return [...set];
  }

  // Render chips
  function renderChips(container, keys, set){
    container.innerHTML='';
    const make=(k)=>{
      const lbl=document.createElement('label'); lbl.className='chip';
      const cb=document.createElement('input'); cb.type='checkbox';
      cb.checked=set.has(k);
      cb.addEventListener('change',()=>{cb.checked?set.add(k):set.delete(k);});
      const span=document.createElement('span'); span.textContent=k;
      lbl.appendChild(cb); lbl.appendChild(span); return lbl;
    };
    keys.forEach(k=>container.appendChild(make(k)));
  }

  // Build table
  function buildTable(rows, cols){
    resultsBody.innerHTML=''; theadRow.innerHTML='';
    if (!rows.length){ resultsTable.style.display='none'; return; }
    cols.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; theadRow.appendChild(th); });
    const frag=document.createDocumentFragment();
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      tr.innerHTML=cols.map(c=>`<td>${esc(r[c])}</td>`).join('');
      frag.appendChild(tr);
    });
    resultsBody.appendChild(frag); resultsTable.style.display='';
  }
  const toCsv=(rows,cols)=>[cols.join(','),...rows.map(r=>cols.map(c=>{const s=r[c]==null?'':String(r[c]);return /[",\r\n]/.test(s)?'"'+s.replace(/"/g,'""')+'"':s;}).join(','))].join('\r\n');

  // Load JSON
  function load(text){
    root=JSON.parse(text);
    fieldEntries = scanFields(root).map(e=>{
      // Make human chain label like users.role_members.account_name
      const chain = e.chainLabel || e.path.replace(/^\$\./,'').replace(/\[\]|\[\*\]/g,'');
      return {...e, chainLabel: chain};
    });
    filteredEntries = fieldEntries;
    renderFieldList();
    setStatus(`Found ${fieldEntries.length.toLocaleString()} fields. Pick one, choose row mode, then outputs.`,`ok`);
    enableRun();
  }

  // Events
  fileInput.addEventListener('change', async e=>{
    const f=e.target.files?.[0]; if(!f) return;
    try{ const t=await f.text(); jsonText.value=t; load(t);}catch(err){ setStatus('Failed to read file: '+String(err),'err'); }
  });
  jsonText.addEventListener('blur', ()=>{ try{ const t=(jsonText.value||'').trim(); if(!t) return; load(t);}catch(_){}});

  clearBtn.addEventListener('click', ()=>{
    root=null; jsonText.value=''; fileInput.value='';
    fieldEntries=[]; filteredEntries=[]; fieldList.innerHTML=''; fieldSearch.value=''; showPaths.checked=false;
    selectedField=null; modeMatch.checked=false; modeParent.checked=false;
    selectedRowFields=new Set(); selectedMatchFields=new Set();
    rowFieldGrid.innerHTML=''; matchFieldGrid.innerHTML='';
    resultsBody.innerHTML=''; theadRow.innerHTML=''; resultsTable.style.display='none';
    setDownloads(false); setStatus('');
    enableRun();
  });

  fieldSearch.addEventListener('input', ()=>{
    const q=fieldSearch.value.toLowerCase().trim();
    filteredEntries = !q ? fieldEntries : fieldEntries.filter(e=> e.chainLabel.toLowerCase().includes(q));
    renderFieldList();
  });
  showPaths.addEventListener('change', renderFieldList);

  fieldList.addEventListener('change', ()=>{
    selectedField = fieldEntries.find(e=> e.path===fieldList.value);
    // compute preview keys for row/match
    const matches = resolveMatches(selectedField.path);
    // row objects for both modes
    const parentObjs = matches.map(nearestParent);
    const matchObjs = matches.map(m=>m.holder);

    renderChips(rowFieldGrid, detectScalarKeys(parentObjs), selectedRowFields);
    renderChips(matchFieldGrid, detectScalarKeys(matchObjs), selectedMatchFields);

    enableRun();
  });

  [modeMatch,modeParent].forEach(el=>el.addEventListener('change', enableRun));

  rowAll.addEventListener('click', ()=>{
    if (!selectedField) return;
    const matches = resolveMatches(selectedField.path);
    selectedRowFields = new Set(detectScalarKeys(matches.map(nearestParent)));
    renderChips(rowFieldGrid, [...selectedRowFields], selectedRowFields);
  });
  rowNone.addEventListener('click', ()=>{ selectedRowFields=new Set(); renderChips(rowFieldGrid, [], selectedRowFields); });

  matchAll.addEventListener('click', ()=>{
    if (!selectedField) return;
    const matches = resolveMatches(selectedField.path);
    selectedMatchFields = new Set(detectScalarKeys(matches.map(m=>m.holder)));
    renderChips(matchFieldGrid, [...selectedMatchFields], selectedMatchFields);
  });
  matchNone.addEventListener('click', ()=>{ selectedMatchFields=new Set(); renderChips(matchFieldGrid, [], selectedMatchFields); });

  valuesInput.addEventListener('input', enableRun);
  [caseInsensitive, exactMatch].forEach(e=>e.addEventListener('change', enableRun));

  runBtn.addEventListener('click', ()=>{
    if (!root || !selectedField) return;
    const allowed = parseVals(valuesInput.value, caseInsensitive.checked);
    const ci=caseInsensitive.checked, exact=exactMatch.checked;
    const matches = resolveMatches(selectedField.path).filter(m=> matchAllowed(allowed, m.value, {ci,exact}));

    const rows=[]; const colsSet=new Set(); const perMatch = modeMatch.checked;
    const prefix = selectedField.holderName ? selectedField.holderName + '_' : 'match_';

    if (perMatch){
      for(const m of matches){
        const rowObj = m.holder;                 // row per matching element
        const parentObj = nearestParent(m);      // for optional row fields
        const out={};
        // row (parent) fields
        for(const k of selectedRowFields){ out[k]= parentObj?.[k] ?? ''; colsSet.add(k); }
        // matched fields
        for(const k of selectedMatchFields){ out[prefix+k]= m.holder?.[k] ?? ''; colsSet.add(prefix+k); }
        // always include the filter value for traceability
        if (!colsSet.has(prefix + '_filter_value')) colsSet.add(prefix + '_filter_value');
        out[prefix + '_filter_value'] = String(m.value);
        rows.push(out);
      }
    } else {
      // per parent (aggregate)
      // group by parent object identity
      const groups = new Map();
      for(const m of matches){
        const parent = nearestParent(m);
        if (!groups.has(parent)) groups.set(parent, []);
        groups.get(parent).push(m);
      }
      for(const [parent, ms] of groups){
        const out={};
        // row fields from parent
        for(const k of selectedRowFields){ out[k]= parent?.[k] ?? ''; colsSet.add(k); }
        // aggregate matched fields to a single column "matches"
        if (selectedMatchFields.size){
          const rendered = ms.map(mm=>{
            const bits=[];
            for(const k of selectedMatchFields){
              const v=mm.holder?.[k];
              if (v!==undefined && v!==null) bits.push(`${k}:${v}`);
            }
            return bits.join(', ');
          }).filter(Boolean).join('; ');
          out['matches']=rendered; colsSet.add('matches');
        } else {
          // at least include the filter values
          out['matches']= ms.map(mm=> String(mm.value)).join('; '); colsSet.add('matches');
        }
        rows.push(out);
      }
    }

    const cols=[...colsSet];
    lastRows=rows; lastCols=cols; buildTable(rows, cols); setDownloads(rows.length>0);

    // stats (per-match: show unique parents + unique filter values)
    if (perMatch){
      const uniqParents = new Set(matches.map(m=> nearestParent(m))).size;
      const uniqVals = new Set(matches.map(m=> String(m.value))).size;
      setStatus(`Rows: ${rows.length.toLocaleString()} • Unique parents: ${uniqParents.toLocaleString()} • Unique filter values: ${uniqVals.toLocaleString()}`, 'ok');
    } else {
      setStatus(`Rows: ${rows.length.toLocaleString()}`, 'ok');
    }
  });

  downloadJsonBtn.addEventListener('click', ()=>{
    if (!lastRows.length) return;
    const blob=new Blob([JSON.stringify(lastRows,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='filtered-output.json';
    document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
  });
  downloadCsvBtn.addEventListener('click', ()=>{
    if (!lastRows.length) return;
    const csv=toCsv(lastRows,lastCols); const blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='filtered-output.csv';
    document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
  });
  copyBtn.addEventListener('click', async()=>{
    if (!lastRows.length) return;
    try{ await navigator.clipboard.writeText(JSON.stringify(lastRows,null,2)); setStatus('Copied JSON to clipboard.','ok'); }
    catch(e){ setStatus('Copy failed: '+e.message,'err'); }
  });

})();
</script>
</body>
</html>
