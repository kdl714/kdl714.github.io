<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flexible JSON Filter — Correct Output Detection</title>
<style>
  :root{--bg:#0b0b10;--panel:#131320;--muted:#9aa0ac;--text:#e9e9f1;--accent:#5b8cff;--stroke:#202036;--field:#0f0f19;--ok:#2ecc71;--err:#ff5c5c}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:32px auto;padding:0 16px}
  .card{background:var(--panel);border:1px solid var(--stroke);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
  header{padding:18px;border-bottom:1px solid var(--stroke);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  header h1{margin:0;font-size:18px}
  header .sub{color:var(--muted);font-size:13px}
  .content{display:grid;grid-template-columns:1fr 1fr;gap:18px;padding:18px}
  .content.single{grid-template-columns:1fr}
  @media(max-width:980px){.content{grid-template-columns:1fr}}
  .section{display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:13px;color:var(--muted)}
  textarea,input[type=text],select{width:100%;padding:12px;border-radius:12px;border:1px solid var(--stroke);background:var(--field);color:var(--text)}
  textarea{min-height:220px;resize:vertical}
  input[type=file]{font-size:13px;max-width:100%}
  .btn{appearance:none;border:none;padding:10px 14px;border-radius:12px;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
  .btn.secondary{background:#2a2a44;color:#d9d9e6}
  .btn.ghost{background:transparent;border:1px solid var(--stroke);color:var(--text)}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .hint{font-size:12px;color:var(--muted)}
  .status{font-size:13px;margin-top:6px}
  .status.ok{color:var(--ok)} .status.err{color:var(--err);white-space:pre-wrap}
  .group{border:1px solid var(--stroke);border-radius:12px;padding:12px;background:#0f0f19}
  .group h3{margin:0 0 8px 0;font-size:13px;color:#bdbdd3}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media(max-width:980px){.two{grid-template-columns:1fr}}
  .listbox{width:100%;min-height:220px;max-height:260px;overflow:auto;padding:0;margin:0;border:1px solid #1e1e33;border-radius:10px;background:#0c0c16}
  .listbox option{padding:10px 12px;border-bottom:1px solid #17172a}
  .chiplist{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:8px;max-height:240px;overflow:auto;padding:8px;background:#0c0c16;border:1px solid #1e1e33;border-radius:10px}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:10px;background:#101022;border:1px solid #232345;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:13px;color:#d6d6e6}
  table{width:100%;border-collapse:separate;border-spacing:0;background:var(--field);border:1px solid var(--stroke);border-radius:12px;overflow:hidden}
  th,td{padding:10px 12px;border-bottom:1px solid #1e1e30;text-align:left;vertical-align:top}
  th{background:#101022;font-size:12px;color:#bdbdd3;position:sticky;top:0}
  tr:last-child td{border-bottom:none}
  .footer{padding:12px 18px;border-top:1px solid var(--stroke);display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between}
  code.bubble{background:#101022;padding:2px 6px;border-radius:8px;border:1px solid #232345;font-family:ui-monospace,Consolas,Menlo,monospace}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <h1>Flexible JSON Filter</h1>
      <div class="sub">Local only • no defaults</div>
    </header>

    <div class="content">
      <!-- LOAD -->
      <div class="section">
        <label>1) Load JSON (choose one):</label>
        <div class="row">
          <input id="fileInput" type="file" accept=".json,application/json"/>
          <button class="btn ghost" id="clearBtn">Clear</button>
        </div>
        <textarea id="jsonText" placeholder="Paste any JSON (object or array)"></textarea>
        <div class="hint">File picker is faster for very large files.</div>
      </div>

      <!-- BUILDER -->
      <div class="section">
        <label>2) Build your query (filter + row mode + outputs)</label>

        <div class="group">
          <h3>Filter field</h3>
          <div class="two">
            <input id="fieldSearch" type="text" placeholder="Search fields… e.g. account_name, email, id">
            <label class="row" style="gap:8px;"><input id="showPaths" type="checkbox"> <span class="hint">Show full JSON paths</span></label>
          </div>
          <select id="fieldList" size="10" class="listbox" title="Pick a field to filter"></select>
          <div class="two">
            <input id="valuesInput" type="text" placeholder="Values (comma-separated)">
            <div class="row">
              <label><input id="caseInsensitive" type="checkbox"> Case-insensitive</label>
              <label><input id="exactMatch" type="checkbox"> Exact match</label>
            </div>
          </div>
          <div class="hint">Items show a friendly chain (e.g. <code class="bubble">users.role_members.account_name</code>) with a sample. Paths are hidden unless toggled.</div>
        </div>

        <div class="group">
          <h3>Row mode</h3>
          <div class="row">
            <label><input type="radio" name="rowmode" id="modeMatch"> Per match (flatten)</label>
            <label><input type="radio" name="rowmode" id="modeParent"> Per parent (aggregate)</label>
          </div>
          <div class="hint">“Parent” = the nearest list ancestor above the matching item (e.g., the <code class="bubble">user</code> that owns a <code class="bubble">role_member</code>).</div>
        </div>

        <div class="group" id="outputsGroup">
          <h3>Output fields</h3>
          <div class="row">
            <strong>Row fields</strong>
            <button class="btn ghost" id="rowAll">All</button>
            <button class="btn ghost" id="rowNone">None</button>
          </div>
          <div id="rowFieldGrid" class="chiplist"></div>

          <div id="matchBlock" style="margin-top:12px;">
            <div class="row" style="margin-top:8px;">
              <strong>Matched item fields</strong>
              <span class="hint">(only when filtering inside a nested list)</span>
              <button class="btn ghost" id="matchAll">All</button>
              <button class="btn ghost" id="matchNone">None</button>
            </div>
            <div id="matchFieldGrid" class="chiplist"></div>
          </div>
        </div>

        <div class="row" style="gap:10px;">
          <button class="btn" id="runBtn" disabled>Run</button>
          <button class="btn secondary" id="downloadJsonBtn" disabled>Download JSON</button>
          <button class="btn secondary" id="downloadCsvBtn" disabled>Download CSV</button>
          <button class="btn ghost" id="copyBtn" disabled>Copy JSON</button>
        </div>
        <div id="status" class="status"></div>
      </div>
    </div>

    <!-- RESULTS -->
    <div class="content single">
      <div class="section">
        <label>Results</label>
        <div style="overflow:auto;max-height:55vh;border-radius:12px">
          <table id="resultsTable" style="display:none;">
            <thead><tr id="theadRow"></tr></thead>
            <tbody id="resultsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="footer">
      <span class="hint">Everything runs locally.</span>
      <span class="hint">If you want wildcards next, we can add them.</span>
    </div>
  </div>
</div>

<script>
(function(){
  // DOM
  const fileInput=document.getElementById('fileInput'), jsonText=document.getElementById('jsonText'), clearBtn=document.getElementById('clearBtn');
  const fieldSearch=document.getElementById('fieldSearch'), showPaths=document.getElementById('showPaths'), fieldList=document.getElementById('fieldList');
  const valuesInput=document.getElementById('valuesInput'), caseInsensitive=document.getElementById('caseInsensitive'), exactMatch=document.getElementById('exactMatch');
  const modeMatch=document.getElementById('modeMatch'), modeParent=document.getElementById('modeParent');
  const rowFieldGrid=document.getElementById('rowFieldGrid'), matchFieldGrid=document.getElementById('matchFieldGrid'), matchBlock=document.getElementById('matchBlock');
  const rowAll=document.getElementById('rowAll'), rowNone=document.getElementById('rowNone'), matchAll=document.getElementById('matchAll'), matchNone=document.getElementById('matchNone');
  const runBtn=document.getElementById('runBtn'), statusEl=document.getElementById('status'), resultsTable=document.getElementById('resultsTable'), theadRow=document.getElementById('theadRow'), resultsBody=document.getElementById('resultsBody');
  const downloadJsonBtn=document.getElementById('downloadJsonBtn'), downloadCsvBtn=document.getElementById('downloadCsvBtn'), copyBtn=document.getElementById('copyBtn');

  // State
  let root=null;
  let entries=[];           // all scalar fields with context
  let filteredEntries=[];
  let selectedEntry=null;
  let selectedRowFields=new Set();
  let selectedMatchFields=new Set();
  let lastRows=[], lastCols=[];

  // Utils
  const esc=v=>String(v??'').replace(/[&<>"']/g,s=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
  const setStatus=(m,k)=>{statusEl.textContent=m||'';statusEl.className='status '+(k||'')}
  const setDownloads=on=>{downloadJsonBtn.disabled=downloadCsvBtn.disabled=copyBtn.disabled=!on}
  const enableRun=()=>{runBtn.disabled=!(root && selectedEntry && valuesInput.value.trim() && (modeMatch.checked||modeParent.checked));}
  const parseVals=(s,ci)=>new Set((s||'').split(',').map(x=>x.trim()).filter(Boolean).map(x=>ci?x.toLowerCase():x));
  const matchAllowed=(allowed,val,{ci,exact})=>{const t=ci?String(val??'').toLowerCase():String(val??'');if(exact)return allowed.has(t);for(const a of allowed)if(t.includes(a))return true;return false;}
  const isColl=tok=>/\[\]|\[\*\]$/.test(tok);
  const base=tok=>tok.replace(/\[\]|\[\*\]/,'');
  const toks=p=>p.split('.');

  // Scan all scalar fields; compute holder & parent collection paths correctly
  function scanFields(root){
    const out=[];
    function walk(node, path){
      if (node==null) return;
      if (Array.isArray(node)){
        for(const el of node) walk(el, path);
      } else if (typeof node==='object'){
        for(const [k,v] of Object.entries(node)){
          const next = path.length? path.concat([k]) : ['$.',k];
          if (v && typeof v==='object'){
            if (Array.isArray(v)) walk(v, [...next.slice(0,-1), next[next.length-1]+'[]']);
            else walk(v, next);
          } else {
            // scalar
            const tokens = next; // tokens up to the holder object + field
            const withField = tokens; // current tokens already at holder; field = k
            const all = withField; // holder tokens
            const collIdx = all.map((t,i)=>isColl(t)?i:-1).filter(i=>i>=0);
            let holderColl, parentColl;
            if (collIdx.length===0){
              holderColl = all.slice(0, all.length-1).join('.') || '$'; // no list ancestors
              parentColl = holderColl;
            } else {
              const last = collIdx[collIdx.length-1];
              const prev = collIdx.length>=2 ? collIdx[collIdx.length-2] : last;
              holderColl = all.slice(0, last+1).join('.');
              parentColl = all.slice(0, prev+1).join('.');
            }
            const fullPath = (all.length? all.join('.') : '$') + '.' + k;
            const chain = (fullPath.replace(/^\$\./,'').replace(/\[\]|\[\*\]/g,''));
            out.push({ path: fullPath, sample:v, holderColl, parentColl, chainLabel: chain, field:k });
          }
        }
      }
    }
    walk(root, ['$']);
    const seen=new Set();
    return out.filter(e=>{if(seen.has(e.path)) return false; seen.add(e.path); return true;});
  }

  // Collect objects at a (possibly collection) path
  function collectObjectsAt(path){
    const parts=toks(path);
    function step(nodes, i){
      if (i>=parts.length) return nodes;
      const tok=parts[i];
      if (tok==='$'||tok==='$.') return step(nodes, i+1);
      const coll=isColl(tok), key=base(tok);
      const next=[];
      for(const n of nodes){
        if (!n || typeof n!=='object') continue;
        if (coll){
          const seq=n[key];
          if (Array.isArray(seq)) seq.forEach(el=>{ if (el && typeof el==='object') next.push(el); });
          else if (seq && typeof seq==='object') Object.values(seq).forEach(el=>{ if (el && typeof el==='object') next.push(el); });
        } else {
          const child=n[key];
          if (child && typeof child==='object') next.push(child);
        }
      }
      return step(next, i+1);
    }
    const res=step([root],0);
    return res;
  }

  function scalarKeysOf(objs){
    const s=new Set();
    const n=Math.min(200, objs.length);
    for(let i=0;i<n;i++){
      const o=objs[i]; if(!o||typeof o!=='object') continue;
      for(const [k,v] of Object.entries(o)) if (v==null || typeof v!=='object') s.add(k);
    }
    return [...s].sort();
  }

  function renderFieldList(){
    fieldList.innerHTML='';
    filteredEntries.forEach(e=>{
      const label = e.chainLabel + (showPaths.checked ? `  •  ${e.path}` : '');
      const opt=document.createElement('option'); opt.value=e.path; opt.textContent=`${label} — sample: ${String(e.sample).slice(0,80)}`;
      fieldList.appendChild(opt);
    });
  }

  function renderChips(container, keys, setRef){
    container.innerHTML='';
    const mk=(k)=>{
      const lbl=document.createElement('label'); lbl.className='chip';
      const cb=document.createElement('input'); cb.type='checkbox';
      cb.checked=setRef.has(k);
      cb.addEventListener('change',()=>{ cb.checked ? setRef.add(k) : setRef.delete(k); });
      const span=document.createElement('span'); span.textContent=k;
      lbl.appendChild(cb); lbl.appendChild(span); return lbl;
    };
    keys.forEach(k=>container.appendChild(mk(k)));
  }

  function buildTable(rows, cols){
    resultsBody.innerHTML=''; theadRow.innerHTML='';
    if (!rows.length){ resultsTable.style.display='none'; return; }
    cols.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; theadRow.appendChild(th); });
    const frag=document.createDocumentFragment();
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      tr.innerHTML=cols.map(c=>`<td>${esc(r[c])}</td>`).join('');
      frag.appendChild(tr);
    });
    resultsBody.appendChild(frag); resultsTable.style.display='';
  }
  const toCsv=(rows,cols)=>[cols.join(','),...rows.map(r=>cols.map(c=>{const s=r[c]==null?'':String(r[c]);return /[",\r\n]/.test(s)?'"'+s.replace(/"/g,'""')+'"':s;}).join(','))].join('\r\n');

  // Load JSON
  function load(text){
    root=JSON.parse(text);
    entries=scanFields(root);
    filteredEntries=entries;
    renderFieldList();
    setStatus(`Found ${entries.length.toLocaleString()} fields. Pick a field, choose row mode, then outputs.`, 'ok');
    enableRun();
  }

  // Events
  fileInput.addEventListener('change', async e=>{
    const f=e.target.files?.[0]; if(!f) return;
    try{ const t=await f.text(); jsonText.value=t; load(t);}catch(err){ setStatus('Failed to read file: '+String(err),'err'); }
  });
  jsonText.addEventListener('blur', ()=>{ try{ const t=(jsonText.value||'').trim(); if(!t) return; load(t);}catch(_){}});

  clearBtn.addEventListener('click', ()=>{
    root=null; jsonText.value=''; fileInput.value='';
    entries=[]; filteredEntries=[]; fieldList.innerHTML=''; fieldSearch.value=''; showPaths.checked=false;
    selectedEntry=null; modeMatch.checked=false; modeParent.checked=false;
    selectedRowFields=new Set(); selectedMatchFields=new Set();
    rowFieldGrid.innerHTML=''; matchFieldGrid.innerHTML=''; matchBlock.style.display='';
    resultsBody.innerHTML=''; theadRow.innerHTML=''; resultsTable.style.display='none';
    setDownloads(false); setStatus(''); enableRun();
  });

  fieldSearch.addEventListener('input', ()=>{
    const q=fieldSearch.value.toLowerCase().trim();
    filteredEntries = !q ? entries : entries.filter(e=> e.chainLabel.toLowerCase().includes(q));
    renderFieldList();
  });
  showPaths.addEventListener('change', renderFieldList);

  fieldList.addEventListener('change', ()=>{
    selectedEntry = entries.find(e=> e.path===fieldList.value);
    if (!selectedEntry) return;

    // Determine the parent and holder collections properly
    const parentObjs = collectObjectsAt(selectedEntry.parentColl);
    const holderObjs = collectObjectsAt(selectedEntry.holderColl);

    // If the selected field lives directly on the parent collection object,
    // holderObjs and parentObjs will be the same (no "matched item" section).
    const sameLevel = selectedEntry.parentColl === selectedEntry.holderColl;

    // Build complete key sets from the FULL collections (not just matches)
    const rowKeys = scalarKeysOf(parentObjs);
    const matchKeys = sameLevel ? [] : scalarKeysOf(holderObjs);

    selectedRowFields=new Set(); selectedMatchFields=new Set();
    renderChips(rowFieldGrid, rowKeys, selectedRowFields);

    if (matchKeys.length){
      matchBlock.style.display='';
      renderChips(matchFieldGrid, matchKeys, selectedMatchFields);
    }else{
      matchBlock.style.display='none';
      matchFieldGrid.innerHTML='';
    }
    enableRun();
  });

  [modeMatch,modeParent].forEach(el=>el.addEventListener('change', enableRun));
  rowAll.addEventListener('click', ()=>{
    const keys=[...rowFieldGrid.querySelectorAll('label.chip span')].map(s=>s.textContent);
    selectedRowFields=new Set(keys); renderChips(rowFieldGrid, keys, selectedRowFields);
  });
  rowNone.addEventListener('click', ()=>{ selectedRowFields=new Set(); renderChips(rowFieldGrid, [], selectedRowFields); });
  matchAll.addEventListener('click', ()=>{
    const keys=[...matchFieldGrid.querySelectorAll('label.chip span')].map(s=>s.textContent);
    selectedMatchFields=new Set(keys); renderChips(matchFieldGrid, keys, selectedMatchFields);
  });
  matchNone.addEventListener('click', ()=>{ selectedMatchFields=new Set(); renderChips(matchFieldGrid, [], selectedMatchFields); });

  valuesInput.addEventListener('input', enableRun);
  [caseInsensitive, exactMatch].forEach(e=>e.addEventListener('change', enableRun));

  // Run
  runBtn.addEventListener('click', ()=>{
    if (!root || !selectedEntry) return;

    const allowed = parseVals(valuesInput.value, caseInsensitive.checked);
    const ci=caseInsensitive.checked, exact=exactMatch.checked;

    // Resolve matches of the selected field, keeping list ancestor stack
    const matches=(function resolveMatches(){
      const p=toks(selectedEntry.path); const res=[];
      function recur(node,i,stack){
        if (i>=p.length) return;
        const tok=p[i];
        if (tok==='$'||tok==='$.') return recur(node,i+1,stack);
        const coll=isColl(tok), key=base(tok);
        if (coll){
          const seq=node?.[key];
          const items=Array.isArray(seq)?seq:(seq&&typeof seq==='object'?Object.values(seq):[]);
          for(const el of items){ if(el&&typeof el==='object') recur(el,i+1,stack.concat([{path:p.slice(0,i+1).join('.'), name:key, obj:el}])) }
        } else {
          if (i===p.length-1){
            const val=node?.[key];
            if (val!==undefined && (typeof val!=='object' || val===null)) res.push({value:val, holder:node, stack});
          } else {
            const nxt=node?.[key]; if(nxt&&typeof nxt==='object') recur(nxt,i+1,stack);
          }
        }
      }
      recur(root,0,[]);
      return res.filter(m=> matchAllowed(allowed,m.value,{ci,exact}));
    })();

    function nearestParent(m){ return m.stack.length? m.stack[m.stack.length-1].obj : m.holder; }

    const perMatch=modeMatch.checked;
    const rows=[]; const cols=new Set();
    const holderName=(function(){const t=toks(selectedEntry.holderColl); return base(t[t.length-1]||'match');})();
    const prefix=holderName?holderName+'_':'match_';

    if (perMatch){
      for(const m of matches){
        const parent=nearestParent(m);
        const out={};
        for(const k of selectedRowFields){ out[k]= parent?.[k] ?? ''; cols.add(k); }
        for(const k of selectedMatchFields){ out[prefix+k]= m.holder?.[k] ?? ''; cols.add(prefix+k); }
        out[prefix+'filter_value']=String(m.value); cols.add(prefix+'filter_value');
        rows.push(out);
      }
      const uniqParents=new Set(matches.map(nearestParent)).size;
      const uniqVals=new Set(matches.map(m=>String(m.value))).size;
      setStatus(`Rows: ${rows.length.toLocaleString()} • Unique parents: ${uniqParents.toLocaleString()} • Unique filter values: ${uniqVals.toLocaleString()}`, 'ok');
    } else {
      // aggregate per parent
      const groups=new Map();
      for(const m of matches){ const p=nearestParent(m); if(!groups.has(p)) groups.set(p,[]); groups.get(p).push(m); }
      for(const [parent,ms] of groups){
        const out={};
        for(const k of selectedRowFields){ out[k]= parent?.[k] ?? ''; cols.add(k); }
        const line = (selectedMatchFields.size
          ? ms.map(mm=>[...selectedMatchFields].map(k=>mm.holder?.[k]!=null?`${k}:${mm.holder[k]}`:'').filter(Boolean).join(', ')).filter(Boolean).join('; ')
          : ms.map(mm=>String(mm.value)).join('; ')
        );
        out['matches']=line; cols.add('matches');
        rows.push(out);
      }
      setStatus(`Rows: ${rows.length.toLocaleString()}`, 'ok');
    }

    const colList=[...cols]; lastRows=rows; lastCols=colList; buildTable(rows,colList); setDownloads(rows.length>0);
  });

  // Downloads / copy
  downloadJsonBtn.addEventListener('click', ()=>{
    if (!lastRows.length) return;
    const blob=new Blob([JSON.stringify(lastRows,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='filtered-output.json';
    document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
  });
  downloadCsvBtn.addEventListener('click', ()=>{
    if (!lastRows.length) return;
    const csv=[lastCols.join(','),...lastRows.map(r=> lastCols.map(c=>{const s=r[c]==null?'':String(r[c]);return /[",\r\n]/.test(s)?'"'+s.replace(/"/g,'""')+'"':s;}).join(','))].join('\r\n');
    const blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='filtered-output.csv';
    document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
  });
  copyBtn.addEventListener('click', async()=>{
    if (!lastRows.length) return;
    try{ await navigator.clipboard.writeText(JSON.stringify(lastRows,null,2)); setStatus('Copied JSON to clipboard.','ok'); }
    catch(e){ setStatus('Copy failed: '+e.message,'err'); }
  });

})();
</script>
</body>
</html>
