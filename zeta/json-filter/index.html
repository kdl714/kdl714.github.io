<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flexible JSON Filter (no defaults)</title>
<style>
  :root{--bg:#0b0b10;--panel:#131320;--muted:#9aa0ac;--text:#e9e9f1;--accent:#5b8cff;--stroke:#202036;--field:#0f0f19;--ok:#2ecc71;--err:#ff5c5c}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:32px auto;padding:0 16px}
  .card{background:var(--panel);border:1px solid var(--stroke);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
  header{padding:18px;border-bottom:1px solid var(--stroke);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  header h1{margin:0;font-size:18px}
  header .sub{color:var(--muted);font-size:13px}
  .content{display:grid;grid-template-columns:1fr 1fr;gap:18px;padding:18px}
  .content.single{grid-template-columns:1fr}
  @media(max-width:980px){.content{grid-template-columns:1fr}}
  .section{display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:13px;color:var(--muted)}
  textarea,input[type=text],select{width:100%;padding:12px;border-radius:12px;border:1px solid var(--stroke);background:var(--field);color:var(--text)}
  textarea{min-height:220px;resize:vertical}
  input[type=file]{font-size:13px;max-width:100%}
  .btn{appearance:none;border:none;padding:10px 14px;border-radius:12px;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
  .btn.secondary{background:#2a2a44;color:#d9d9e6}
  .btn.ghost{background:transparent;border:1px solid var(--stroke);color:var(--text)}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .hint{font-size:12px;color:var(--muted)}
  .status{font-size:13px;margin-top:6px}
  .status.ok{color:var(--ok)} .status.err{color:var(--err);white-space:pre-wrap}

  .group{border:1px solid var(--stroke);border-radius:12px;padding:12px;background:#0f0f19}
  .group h3{margin:0 0 8px 0;font-size:13px;color:#bdbdd3}
  .chiplist{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:8px;max-height:240px;overflow:auto;padding:8px;background:#0c0c16;border:1px solid #1e1e33;border-radius:10px}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:10px;background:#101022;border:1px solid #232345;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:13px;color:#d6d6e6}
  .searchbox{display:flex;gap:8px}
  .searchbox input{flex:1}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media(max-width:980px){.two{grid-template-columns:1fr}}
  table{width:100%;border-collapse:separate;border-spacing:0;background:var(--field);border:1px solid var(--stroke);border-radius:12px;overflow:hidden}
  th,td{padding:10px 12px;border-bottom:1px solid #1e1e30;text-align:left;vertical-align:top}
  th{background:#101022;font-size:12px;color:#bdbdd3;position:sticky;top:0}
  tr:last-child td{border-bottom:none}
  .footer{padding:12px 18px;border-top:1px solid var(--stroke);display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between}
  code.bubble{background:#101022;padding:2px 6px;border-radius:8px;border:1px solid #232345;font-family:ui-monospace,Consolas,Menlo,monospace}
  .danger{color:var(--err)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <h1>Flexible JSON Filter</h1>
      <div class="sub">No installs • Everything runs locally • No defaults</div>
    </header>

    <div class="content">
      <!-- LEFT: Load -->
      <div class="section">
        <label>1) Load JSON (choose one):</label>
        <div class="row">
          <input id="fileInput" type="file" accept=".json,application/json"/>
          <button class="btn ghost" id="clearBtn">Clear</button>
        </div>
        <textarea id="jsonText" placeholder="Paste any JSON (object or array)"></textarea>
        <div class="hint">Tip: file picker is faster for very large files.</div>
      </div>

      <!-- RIGHT: Unified Builder -->
      <div class="section">
        <label>2) Build your query (filter + row scope + outputs)</label>

        <div class="group">
          <h3>Filter field (search across entire JSON)</h3>
          <div class="searchbox">
            <input id="pathSearch" type="text" placeholder="Search paths… (e.g. account_name, email, id)">
            <select id="filterPath" size="8" title="Select a field path found in the JSON" style="min-height:160px;width:100%"></select>
          </div>
          <div class="two">
            <input id="valuesInput" type="text" placeholder="Values to match (comma-separated)">
            <div class="row">
              <label><input id="caseInsensitive" type="checkbox"> Case-insensitive</label>
              <label><input id="exactMatch" type="checkbox"> Exact match</label>
            </div>
          </div>
          <div class="hint">Paths use a simple JSONPath-like form with <code class="bubble">[]</code> to indicate collections, e.g. <code class="bubble">$.users[].role_members[].account_name</code>.</div>
        </div>

        <div class="group">
          <h3>Row scope (what becomes a “row”)</h3>
          <div class="row">
            <label><input type="radio" name="rowmode" id="rowMatch"> One row per <em>matching element’s object</em></label>
            <label><input type="radio" name="rowmode" id="rowAggregate"> Aggregate matches to ancestor:</label>
            <select id="ancestorSelect" disabled title="Pick an ancestor object to aggregate to"></select>
          </div>
          <div class="row">
            <label>Unique by (optional for stats):</label>
            <select id="uniqueBy" disabled title="Pick a field on your row object to compute unique counts"></select>
          </div>
          <div class="hint">No defaults here — pick what you need. “Aggregate” lets you roll up matches to an ancestor object (e.g., from <code class="bubble">role_members</code> to its parent <code class="bubble">user</code>).</div>
        </div>

        <div class="group">
          <h3>Output fields (relative to your chosen row)</h3>
          <div class="row">
            <button class="btn ghost" id="selectAll">All</button>
            <button class="btn ghost" id="selectNone">None</button>
            <span class="hint">No defaults are preselected.</span>
          </div>
          <div id="outputGrid" class="chiplist"></div>
          <div class="row">
            <input id="customField" type="text" placeholder="Add custom relative path (e.g. profile.name or meta.code)">
            <button class="btn secondary" id="addCustom">Add</button>
          </div>
        </div>

        <div class="row" style="gap:10px;">
          <button class="btn" id="runBtn" disabled>Run</button>
          <button class="btn secondary" id="downloadJsonBtn" disabled>Download JSON</button>
          <button class="btn secondary" id="downloadCsvBtn" disabled>Download CSV</button>
          <button class="btn ghost" id="copyBtn" disabled>Copy JSON</button>
        </div>
        <div id="status" class="status"></div>
      </div>
    </div>

    <!-- RESULTS -->
    <div class="content single">
      <div class="section">
        <label>Results</label>
        <div style="overflow:auto;max-height:55vh;border-radius:12px">
          <table id="resultsTable" style="display:none;">
            <thead><tr id="theadRow"></tr></thead>
            <tbody id="resultsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="footer">
      <span class="hint">Everything is processed locally in your browser.</span>
      <span class="hint">If you want JSONPath wildcards like <code class="bubble">*</code> next, I can add them.</span>
    </div>
  </div>
</div>

<script>
(function(){
  // ---- DOM
  const fileInput = document.getElementById('fileInput');
  const jsonText = document.getElementById('jsonText');
  const clearBtn = document.getElementById('clearBtn');

  const pathSearch = document.getElementById('pathSearch');
  const filterPathSel = document.getElementById('filterPath');
  const valuesInput = document.getElementById('valuesInput');
  const caseInsensitive = document.getElementById('caseInsensitive');
  const exactMatch = document.getElementById('exactMatch');

  const rowMatch = document.getElementById('rowMatch');
  const rowAggregate = document.getElementById('rowAggregate');
  const ancestorSelect = document.getElementById('ancestorSelect');
  const uniqueBy = document.getElementById('uniqueBy');

  const outputGrid = document.getElementById('outputGrid');
  const selectAllBtn = document.getElementById('selectAll');
  const selectNoneBtn = document.getElementById('selectNone');
  const customField = document.getElementById('customField');
  const addCustom = document.getElementById('addCustom');

  const runBtn = document.getElementById('runBtn');
  const statusEl = document.getElementById('status');
  const resultsTable = document.getElementById('resultsTable');
  const theadRow = document.getElementById('theadRow');
  const resultsBody = document.getElementById('resultsBody');
  const downloadJsonBtn = document.getElementById('downloadJsonBtn');
  const downloadCsvBtn = document.getElementById('downloadCsvBtn');
  const copyBtn = document.getElementById('copyBtn');

  // ---- State
  let root = null;
  let scalarPaths = []; // [{path, sample, ancestors: ['$.users[]','$.users[].role_members[]'], holder:'$.users[].role_members[]'}]
  let filteredScalarPaths = [];
  let selectedOutput = new Set();       // relative to row object
  let customOutputs = new Set();        // user-added relative paths
  let currentRowCandidates = [];        // list of {label, path} for ancestorSelect
  let currentRowFieldList = [];         // union of fields for row object
  let lastRows = [];
  let lastColumns = [];

  // ---- Utils
  const esc = v => String(v ?? '').replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
  const setStatus = (m,k)=>{statusEl.textContent=m||'';statusEl.className='status '+(k||'')}
  const setDownloads = on => {downloadJsonBtn.disabled=downloadCsvBtn.disabled=copyBtn.disabled=!on}
  const enableRunIfReady = ()=> {
    const hasPath = !!filterPathSel.value;
    const hasValues = !!valuesInput.value.trim();
    const rowModeChosen = rowMatch.checked || rowAggregate.checked;
    const aggOk = (!rowAggregate.checked) || (!!ancestorSelect.value);
    runBtn.disabled = !(root && hasPath && hasValues && rowModeChosen && aggOk);
  };

  function parseValues(s,ci){ return new Set((s||'').split(',').map(x=>x.trim()).filter(Boolean).map(x=>ci?x.toLowerCase():x)); }
  function matchesAllowed(allowed,val,{ci,exact}){
    const t = ci ? String(val??'').toLowerCase() : String(val??'');
    if (exact) return allowed.has(t);
    for (const a of allowed) if (t.includes(a)) return true;
    return false;
  }

  // ----- Path utilities (supports tokens like foo, foo[], nested.foo[], $.root[], etc.)
  function tokenize(path){
    const p = path.replace(/^\$\./,'$.' ).replace(/^\$/,'$');
    const parts = p.split('.'); // keeps '[]' suffix on tokens
    return parts;
  }
  function isCollectionToken(tok){ return tok.endsWith('[]') || tok.endsWith('[*]'); }
  function baseName(tok){ return tok.replace(/\[\]|\[\*\]/,''); }

  // Enumerate *all* scalar field paths across the JSON
  function scanScalarPaths(root){
    const out = [];
    function walk(node, tokens, ancestors, holderPath){
      if (node===null || node===undefined) return;

      if (Array.isArray(node)){
        const t = tokens.length?tokens[tokens.length-1]: '$';
        // iterate
        for (let i=0;i<node.length;i++){
          const el = node[i];
          walk(el, tokens, ancestors, holderPath); // element inherits same holder
        }
      } else if (typeof node === 'object'){
        // record this object as a potential holder if last token denotes a collection
        const parentTok = tokens[tokens.length-1] || '$';
        let newHolder = holderPath;
        if (isCollectionToken(parentTok)) newHolder = tokens.join('.');
        // add ancestor collection path when parentTok is collection
        const newAncestors = [...ancestors];
        if (isCollectionToken(parentTok)) newAncestors.push(tokens.join('.'));

        for (const [k,v] of Object.entries(node)){
          const tok = k;
          const nextTokens = tokens.length? [...tokens, tok] : ['$.', tok];
          if (v && typeof v === 'object'){
            // arrays and objects
            if (Array.isArray(v)){
              walk(v, [...nextTokens.slice(0,-1), nextTokens[nextTokens.length-1]+'[]'], newAncestors, newHolder);
            }else{
              walk(v, nextTokens, newAncestors, newHolder);
            }
          } else {
            // scalar -> record path
            const path = (tokens.length?tokens.join('.')+'.':'$.' ) + k;
            out.push({ path, sample: v, ancestors: newAncestors, holder: newHolder || tokens.join('.') });
          }
        }
      }
    }
    walk(root, ['$'], [], '$');
    // Deduplicate by path (keep first sample)
    const seen=new Set();
    return out.filter(p=>{ if(seen.has(p.path)) return false; seen.add(p.path); return true; });
  }

  // Given a field path, offer ancestor row candidates (matching element’s object + any ancestor collection objects)
  function rowCandidatesForField(fieldPath){
    const entry = scalarPaths.find(p => p.path===fieldPath);
    if (!entry) return [];
    const cands = [];
    // holder object of the field
    cands.push({label:'(matching element object) '+entry.holder, path:entry.holder});
    // ancestor collections (closest first)
    for (let i=entry.ancestors.length-1;i>=0;i--){
      cands.push({label: 'ancestor '+entry.ancestors[i], path: entry.ancestors[i]});
    }
    return cands;
  }

  // Resolve all matches for a scalar path, including their object contexts + ancestor objects
  function resolveMatchesForPath(path){
    const tokens = tokenize(path);
    const res = [];
    function recur(node, idx, stack){
      if (idx >= tokens.length) return;
      const tok = tokens[idx];
      if (tok==='$' || tok==='$.') { recur(node, idx+1, stack); return; }
      const coll = isCollectionToken(tok), key = baseName(tok);
      if (coll){
        const next = node?.[key];
        if (!next) return;
        const items = Array.isArray(next) ? next : (typeof next==='object' ? Object.values(next) : []);
        for (const el of items) {
          if (el && typeof el==='object') recur(el, idx+1, stack.concat({type:'collection', key, obj:el, path: tokens.slice(0,idx+1).join('.')}));
        }
      }else{
        if (idx === tokens.length-1){
          // last token -> scalar value at node[key]
          const holderObj = node;
          const val = holderObj?.[key];
          if (val!==undefined && (typeof val!=='object' || val===null)){
            res.push({ value: val, holder: holderObj, stack });
          }
          return;
        } else {
          const next = node?.[key];
          if (next && typeof next==='object'){
            recur(next, idx+1, stack.concat({type:'object', key, obj:next, path: tokens.slice(0,idx+1).join('.')}));
          }
        }
      }
    }
    recur(root, 0, []);
    return res;
  }

  // From a match context, extract the "row object" according to row mode + ancestor choice
  function rowObjectFromMatch(match, mode, ancestorPath){
    if (mode==='match') return match.holder;
    if (mode==='agg' && ancestorPath){
      // find closest stack entry whose path equals ancestorPath
      for (let i=match.stack.length-1;i>=0;i--){
        if (match.stack[i].path === ancestorPath) return match.stack[i].obj;
      }
    }
    return null;
  }

  // For a given row object array, build available field list (union of scalar keys up to some depth)
  function detectRowFields(rows){
    const keys = new Set();
    const max = Math.min(50, rows.length);
    for (let i=0;i<max;i++){
      const r = rows[i];
      if (!r || typeof r!=='object') continue;
      for (const [k,v] of Object.entries(r)){
        if (v===null || typeof v!=='object') keys.add(k);
      }
    }
    return [...keys];
  }

  function getRelPath(obj, rel){
    if (!rel) return undefined;
    const parts = rel.split('.').filter(Boolean);
    let cur = obj;
    for (const p of parts){
      if (cur==null) return undefined;
      cur = cur[p];
    }
    return cur;
  }

  function buildTable(rows, cols){
    resultsBody.innerHTML=''; theadRow.innerHTML='';
    if (!rows.length){ resultsTable.style.display='none'; return; }
    cols.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; theadRow.appendChild(th); });
    const frag=document.createDocumentFragment();
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      tr.innerHTML = cols.map(c => `<td>${esc(r[c])}</td>`).join('');
      frag.appendChild(tr);
    });
    resultsBody.appendChild(frag);
    resultsTable.style.display='';
  }

  function toCsv(rows, cols){
    const header=cols.join(',');
    const lines=[header];
    for(const r of rows){
      const fields=cols.map(c=>{
        const s = r[c]==null ? '' : String(r[c]);
        return /[",\r\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
      });
      lines.push(fields.join(','));
    }
    return lines.join('\r\n');
  }

  // ---- Rendering helpers
  function renderFilterPathOptions(){
    filterPathSel.innerHTML='';
    filteredScalarPaths.forEach(p=>{
      const opt=document.createElement('option');
      opt.value=p.path;
      opt.textContent=`${p.path} — sample: ${String(p.sample).slice(0,60)}`;
      filterPathSel.appendChild(opt);
    });
  }
  function renderOutputGrid(fieldNames){
    outputGrid.innerHTML='';
    const makeChip=(name)=>{
      const lbl=document.createElement('label'); lbl.className='chip';
      const cb=document.createElement('input'); cb.type='checkbox';
      cb.checked = selectedOutput.has(name);
      cb.addEventListener('change',()=>{ cb.checked ? selectedOutput.add(name) : selectedOutput.delete(name); });
      const span=document.createElement('span'); span.textContent=name;
      lbl.appendChild(cb); lbl.appendChild(span); return lbl;
    };
    fieldNames.forEach(n=> outputGrid.appendChild(makeChip(n)));
    // Include custom fields again if not in autodetected
    [...customOutputs].forEach(n=> { if (!fieldNames.includes(n)) outputGrid.appendChild(makeChip(n)); });
  }
  function renderAncestors(){
    const field = filterPathSel.value;
    currentRowCandidates = rowCandidatesForField(field);
    ancestorSelect.innerHTML='';
    currentRowCandidates.slice(1).forEach(c=>{
      const o=document.createElement('option'); o.value=c.path; o.textContent=c.label; ancestorSelect.appendChild(o);
    });
    ancestorSelect.disabled = !rowAggregate.checked || ancestorSelect.options.length===0;
  }
  function refreshRowFieldsPreview(){
    // when a row mode is picked, compute a few row objects to list fields
    const field = filterPathSel.value; if (!field) return;
    const matches = resolveMatchesForPath(field);
    const mode = rowMatch.checked ? 'match' : (rowAggregate.checked ? 'agg' : null);
    const anc = rowAggregate.checked ? ancestorSelect.value : null;
    if (!mode || (mode==='agg' && !anc)) { currentRowFieldList=[]; renderOutputGrid([]); uniqueBy.innerHTML=''; uniqueBy.disabled=true; return; }

    const rows = [];
    for (const m of matches){
      const rowObj = rowObjectFromMatch(m, mode, anc);
      if (rowObj) rows.push(rowObj);
    }
    currentRowFieldList = detectRowFields(rows);
    renderOutputGrid(currentRowFieldList);

    // Unique-by options (no defaults)
    uniqueBy.innerHTML='';
    currentRowFieldList.forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=k; uniqueBy.appendChild(o); });
    uniqueBy.disabled = !rowMatch.checked && !rowAggregate.checked;
  }

  // ---- Actions
  function run(){
    const filterPath = filterPathSel.value;
    const allowed = parseValues(valuesInput.value, caseInsensitive.checked);
    const ci = caseInsensitive.checked, exact = exactMatch.checked;
    const mode = rowMatch.checked ? 'match' : (rowAggregate.checked ? 'agg' : null);
    const anc = rowAggregate.checked ? ancestorSelect.value : null;

    const t0 = performance.now();
    const matches = resolveMatchesForPath(filterPath).filter(m => matchesAllowed(allowed, m.value, {ci,exact}));
    const rows = [];
    const rowObjs = [];

    for (const m of matches){
      const rowObj = rowObjectFromMatch(m, mode, anc);
      if (!rowObj) continue;
      rowObjs.push(rowObj);

      const out = {};
      const cols = [...selectedOutput, ...customOutputs];
      if (cols.length===0){
        // No selected outputs: provide a readable JSON column (generic, not a domain default)
        out['row_json'] = JSON.stringify(rowObj);
      } else {
        cols.forEach(rel => {
          let v = getRelPath(rowObj, rel);
          if (typeof v === 'object') v = JSON.stringify(v);
          out[rel] = v ?? '';
        });
      }
      // Always helpful to include the filter value column for traceability when per-match rows
      if (mode==='match'){ out['__filter_value'] = String(m.value); }
      rows.push(out);
    }

    // Columns
    let columns = rows.length ? Object.keys(rows[0]) : [];
    // Guarantee consistent column order (selected outputs first)
    if (rows.length && selectedOutput.size){
      const preferred = [...selectedOutput, ...customOutputs];
      columns = [...preferred, ...columns.filter(c => !preferred.includes(c))];
    }

    // Stats: show total + unique counts when per-match mode
    const t1 = performance.now();
    lastRows = rows; lastColumns = columns; buildTable(rows, columns);
    setDownloads(rows.length>0);

    if (mode==='match'){
      const uniqValSet = new Set(rows.map(r => r['__filter_value']));
      const uniqByField = uniqueBy.value || null;
      if (uniqByField){
        const uniqRec = new Set(rowObjs.map(r => String(getRelPath(r, uniqByField)))).size;
        setStatus(`Rows: ${rows.length.toLocaleString()} • Unique "${uniqByField}": ${uniqRec.toLocaleString()} • Unique filter values: ${uniqValSet.size.toLocaleString()} — ${(t1-t0).toFixed(1)}ms.`, 'ok');
      }else{
        setStatus(`Rows: ${rows.length.toLocaleString()} • Unique filter values: ${uniqValSet.size.toLocaleString()} — ${(t1-t0).toFixed(1)}ms.`, 'ok');
      }
    } else {
      setStatus(`Matched ${rows.length.toLocaleString()} row(s) — ${(t1-t0).toFixed(1)}ms.`, 'ok');
    }
  }

  // ---- Event wiring
  function loadAndScan(text){
    root = JSON.parse(text);
    scalarPaths = scanScalarPaths(root);
    filteredScalarPaths = scalarPaths;
    renderFilterPathOptions();
    setStatus(`Scanned ${scalarPaths.length} field path(s). Choose a filter field, row scope, and outputs.`, 'ok');
    enableRunIfReady();
  }

  fileInput.addEventListener('change', async e=>{
    const f=e.target.files?.[0]; if(!f) return;
    try{ const t=await f.text(); jsonText.value=t; loadAndScan(t); }catch(err){ setStatus('Failed to read file: '+String(err),'err'); }
  });
  jsonText.addEventListener('blur', ()=>{
    try{ const raw=(jsonText.value||'').trim(); if(!raw) return; loadAndScan(raw); }catch(_){}
  });

  clearBtn.addEventListener('click', ()=>{
    root=null; jsonText.value=''; fileInput.value='';
    scalarPaths=[]; filteredScalarPaths=[]; filterPathSel.innerHTML='';
    valuesInput.value=''; caseInsensitive.checked=false; exactMatch.checked=false;
    rowMatch.checked=false; rowAggregate.checked=false; ancestorSelect.innerHTML=''; ancestorSelect.disabled=true;
    uniqueBy.innerHTML=''; uniqueBy.disabled=true;
    selectedOutput=new Set(); customOutputs=new Set(); outputGrid.innerHTML='';
    resultsBody.innerHTML=''; theadRow.innerHTML=''; resultsTable.style.display='none'; setDownloads(false);
    setStatus('');
    enableRunIfReady();
  });

  pathSearch.addEventListener('input', ()=>{
    const q = pathSearch.value.toLowerCase().trim();
    filteredScalarPaths = !q ? scalarPaths : scalarPaths.filter(p => p.path.toLowerCase().includes(q));
    renderFilterPathOptions();
    enableRunIfReady();
  });

  filterPathSel.addEventListener('change', ()=>{
    renderAncestors();
    // Force re-pick of row mode to avoid silent defaults
    uniqueBy.innerHTML=''; uniqueBy.disabled=true;
    selectedOutput=new Set(); customOutputs=new Set(); renderOutputGrid([]);
    enableRunIfReady();
  });

  rowMatch.addEventListener('change', ()=>{
    ancestorSelect.disabled = true;
    refreshRowFieldsPreview();
    enableRunIfReady();
  });
  rowAggregate.addEventListener('change', ()=>{
    ancestorSelect.disabled = !rowAggregate.checked || ancestorSelect.options.length===0;
    refreshRowFieldsPreview();
    enableRunIfReady();
  });
  ancestorSelect.addEventListener('change', ()=>{
    refreshRowFieldsPreview();
    enableRunIfReady();
  });

  selectAllBtn.addEventListener('click', ()=>{
    currentRowFieldList.forEach(f => selectedOutput.add(f));
    renderOutputGrid(currentRowFieldList);
  });
  selectNoneBtn.addEventListener('click', ()=>{
    selectedOutput.clear();
    renderOutputGrid(currentRowFieldList);
  });
  addCustom.addEventListener('click', ()=>{
    const rel = (customField.value||'').trim();
    if (!rel) return;
    customOutputs.add(rel);
    selectedOutput.add(rel);
    renderOutputGrid(currentRowFieldList);
    customField.value='';
  });

  valuesInput.addEventListener('input', enableRunIfReady);
  [caseInsensitive, exactMatch].forEach(el=> el.addEventListener('change', enableRunIfReady));
  runBtn.addEventListener('click', run);

  downloadJsonBtn.addEventListener('click', ()=>{
    if (!lastRows.length) return;
    const blob = new Blob([JSON.stringify(lastRows,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='filtered-output.json';
    document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
  });
  downloadCsvBtn.addEventListener('click', ()=>{
    if (!lastRows.length) return;
    const csv = toCsv(lastRows, lastColumns);
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8'});
    const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='filtered-output.csv';
    document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
  });
  copyBtn.addEventListener('click', async ()=>{
    if (!lastRows.length) return;
    try{ await navigator.clipboard.writeText(JSON.stringify(lastRows,null,2)); setStatus('Copied JSON to clipboard.','ok'); }
    catch(e){ setStatus('Copy failed: '+e.message,'err'); }
  });

})();
</script>
</body>
</html>
