<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flexible JSON Filter — Clean UI</title>
<style>
  :root{--bg:#0b0b10;--panel:#131320;--muted:#9aa0ac;--text:#e9e9f1;--accent:#5b8cff;--stroke:#202036;--field:#0f0f19;--ok:#2ecc71;--err:#ff5c5c}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:32px auto;padding:0 16px}
  .card{background:var(--panel);border:1px solid var(--stroke);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
  header{padding:18px;border-bottom:1px solid var(--stroke);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  header h1{margin:0;font-size:18px}
  header .sub{color:var(--muted);font-size:13px}
  .content{display:grid;grid-template-columns:1fr 1fr;gap:18px;padding:18px}
  .content.single{grid-template-columns:1fr}
  @media(max-width:980px){.content{grid-template-columns:1fr}}
  .section{display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:13px;color:var(--muted)}
  textarea,input[type=text],select{width:100%;padding:12px;border-radius:12px;border:1px solid var(--stroke);background:var(--field);color:var(--text)}
  textarea{min-height:220px;resize:vertical}
  input[type=file]{font-size:13px;max-width:100%}
  .btn{appearance:none;border:none;padding:10px 14px;border-radius:12px;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
  .btn.secondary{background:#2a2a44;color:#d9d9e6}
  .btn.ghost{background:transparent;border:1px solid var(--stroke);color:var(--text)}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .hint{font-size:12px;color:var(--muted)}
  .status{font-size:13px;margin-top:6px}
  .status.ok{color:var(--ok)} .status.err{color:var(--err);white-space:pre-wrap}

  /* Field browser */
  .browser{border:1px solid var(--stroke);border-radius:12px;background:#0f0f19;padding:10px}
  .search{display:flex;gap:8px;margin-bottom:8px}
  .list{max-height:240px;overflow:auto;display:flex;flex-direction:column;gap:6px}
  .item{display:flex;justify-content:space-between;align-items:center;gap:10px;padding:10px;border:1px solid #1e1e33;border-radius:10px;background:#101022;cursor:pointer}
  .item:hover{border-color:#2b2b55}
  .item.active{outline:2px solid var(--accent)}
  .name{font-weight:600}
  .sample{color:#cdd0e4;font-size:12px;opacity:.9}
  .badge{font-size:11px;color:#cfd2e8;background:#0b0b16;border:1px solid #1f1f35;border-radius:999px;padding:4px 8px;white-space:nowrap}

  /* Field checkboxes */
  .chiplist{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:8px;max-height:240px;overflow:auto;padding:8px;background:#0c0c16;border:1px solid #1e1e33;border-radius:10px}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:10px;background:#101022;border:1px solid #232345;font-size:13px;color:#d6d6e6}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media(max-width:980px){.two{grid-template-columns:1fr}}

  table{width:100%;border-collapse:separate;border-spacing:0;background:var(--field);border:1px solid var(--stroke);border-radius:12px;overflow:hidden}
  th,td{padding:10px 12px;border-bottom:1px solid #1e1e30;text-align:left;vertical-align:top}
  th{background:#101022;font-size:12px;color:#bdbdd3;position:sticky;top:0}
  tr:last-child td{border-bottom:none}

  .footer{padding:12px 18px;border-top:1px solid var(--stroke);display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between}
  code.bubble{background:#101022;padding:2px 6px;border-radius:8px;border:1px solid #232345;font-family:ui-monospace,Consolas,Menlo,monospace}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <h1>Flexible JSON Filter</h1>
      <div class="sub">No installs • Everything runs locally • No defaults</div>
    </header>

    <div class="content">
      <!-- Load -->
      <div class="section">
        <label>1) Load JSON</label>
        <div class="row">
          <input id="fileInput" type="file" accept=".json,application/json"/>
          <button class="btn ghost" id="clearBtn">Clear</button>
        </div>
        <textarea id="jsonText" placeholder="Paste any JSON (object or array)"></textarea>
        <div class="hint">For very large files, using the file picker is faster.</div>
      </div>

      <!-- Build -->
      <div class="section">
        <label>2) Build your query</label>

        <!-- Filter field -->
        <div class="browser">
          <div class="search">
            <input id="searchInput" type="text" placeholder="Search fields by name (e.g., account_name, email, id)"/>
          </div>
          <div id="fieldList" class="list"></div>
          <div class="hint" id="fieldCount"></div>
        </div>

        <div class="two">
          <input id="valuesInput" type="text" placeholder="Values to match (comma-separated)"/>
          <div class="row">
            <label><input id="ci" type="checkbox"> Case-insensitive</label>
            <label><input id="exact" type="checkbox"> Exact match</label>
          </div>
        </div>

        <!-- Row mode -->
        <div class="row" style="margin-top:8px;">
          <label><input type="radio" name="mode" id="modeMatch"> One row per <em>match</em></label>
          <label><input type="radio" name="mode" id="modeRecord"> One row per <em>record</em> (aggregated)</label>
          <span class="hint" id="recordHint"></span>
        </div>

        <!-- Output fields -->
        <div class="two">
          <div>
            <div class="row" style="justify-content:space-between">
              <label>Record fields</label>
              <div class="row"><button class="btn ghost" id="recAll">All</button><button class="btn ghost" id="recNone">None</button></div>
            </div>
            <div id="recGrid" class="chiplist"></div>
          </div>
          <div>
            <div class="row" style="justify-content:space-between">
              <label>Nested fields <span class="hint" id="nestedLabel"></span></label>
              <div class="row"><button class="btn ghost" id="nestAll">All</button><button class="btn ghost" id="nestNone">None</button></div>
            </div>
            <div id="nestGrid" class="chiplist"></div>
          </div>
        </div>

        <!-- Unique-by (only used in per-match stats; optional) -->
        <div class="row">
          <label>Unique by (optional for stats):</label>
          <select id="uniqueBy" disabled title="Choose a record field to compute unique counts"></select>
        </div>

        <div class="row" style="gap:10px;margin-top:6px;">
          <button class="btn" id="runBtn" disabled>Run</button>
          <button class="btn secondary" id="downloadJsonBtn" disabled>Download JSON</button>
          <button class="btn secondary" id="downloadCsvBtn" disabled>Download CSV</button>
          <button class="btn ghost" id="copyBtn" disabled>Copy JSON</button>
        </div>
        <div id="status" class="status"></div>
      </div>
    </div>

    <!-- Results -->
    <div class="content single">
      <div class="section">
        <label>Results</label>
        <div style="overflow:auto;max-height:55vh;border-radius:12px">
          <table id="resultsTable" style="display:none;">
            <thead><tr id="theadRow"></tr></thead>
            <tbody id="resultsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="footer">
      <span class="hint">All processing is local; nothing is uploaded.</span>
      <span class="hint">Want wildcard search next? Happy to add.</span>
    </div>
  </div>
</div>

<script>
(function(){
  // ---- DOM
  const fileInput = document.getElementById('fileInput');
  const jsonText  = document.getElementById('jsonText');
  const clearBtn  = document.getElementById('clearBtn');

  const searchInput = document.getElementById('searchInput');
  const fieldList   = document.getElementById('fieldList');
  const fieldCount  = document.getElementById('fieldCount');

  const valuesInput = document.getElementById('valuesInput');
  const ci    = document.getElementById('ci');
  const exact = document.getElementById('exact');

  const modeMatch  = document.getElementById('modeMatch');
  const modeRecord = document.getElementById('modeRecord');
  const recordHint = document.getElementById('recordHint');

  const recGrid   = document.getElementById('recGrid');
  const nestGrid  = document.getElementById('nestGrid');
  const recAll    = document.getElementById('recAll');
  const recNone   = document.getElementById('recNone');
  const nestAll   = document.getElementById('nestAll');
  const nestNone  = document.getElementById('nestNone');
  const nestedLabel = document.getElementById('nestedLabel');

  const uniqueBy = document.getElementById('uniqueBy');

  const runBtn = document.getElementById('runBtn');
  const downloadJsonBtn = document.getElementById('downloadJsonBtn');
  const downloadCsvBtn  = document.getElementById('downloadCsvBtn');
  const copyBtn = document.getElementById('copyBtn');
  const statusEl = document.getElementById('status');

  const resultsTable = document.getElementById('resultsTable');
  const theadRow     = document.getElementById('theadRow');
  const resultsBody  = document.getElementById('resultsBody');

  // ---- State
  let root = null;
  let fieldEntries = []; // [{key:'account_name', sample, context:'users › role_members', holderPath, recordPath, holderName, recordName}]
  let filteredEntries = [];
  let selectedField = null; // entry
  let recFields = [];   // scalar keys on record object
  let nestFields = [];  // scalar keys on holder object
  let selRec = new Set();   // selected output fields for record
  let selNest = new Set();  // selected output fields for nested
  let lastRows = [];
  let lastCols = [];

  // ---- Utilities
  const esc = v => String(v ?? '').replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
  const setStatus = (m,k)=>{statusEl.textContent=m||'';statusEl.className='status '+(k||'')}
  const setDownloads = on => {downloadJsonBtn.disabled=downloadCsvBtn.disabled=copyBtn.disabled=!on}
  const enableRun = ()=>{
    const ready = root && selectedField && valuesInput.value.trim() && (modeMatch.checked || modeRecord.checked);
    runBtn.disabled = !ready;
  };
  const valuesSet = (s,lower)=> new Set((s||'').split(',').map(t=>t.trim()).filter(Boolean).map(x=>lower?x.toLowerCase():x));
  const matchesAllowed = (allowed,val,{lower,exact})=>{
    const t = lower ? String(val??'').toLowerCase() : String(val??'');
    if (exact) return allowed.has(t);
    for (const a of allowed) if (t.includes(a)) return true;
    return false;
  };

  // ---- Scanner: collect scalar fields with context (hide raw paths)
  function scan(root){
    const out = [];
    function walk(node, tokens, arrayTrail){
      if (node === null || node === undefined) return;
      if (Array.isArray(node)){
        const name = tokens[tokens.length-1] || '$';
        const arrName = name?.replace(/\[\]|\[\*\]/g,'') || '(array)';
        // iterate
        for (const el of node){
          if (el && typeof el==='object'){
            walk(el, tokens, arrayTrail.concat(arrName));
          }
        }
      } else if (typeof node === 'object'){
        for (const [k,v] of Object.entries(node)){
          if (v && typeof v === 'object'){
            if (Array.isArray(v)){
              walk(v, [...tokens,k+'[]'], arrayTrail); // we’ll append when diving in
              // entering array -> next recursion will add to arrayTrail
              walk(v, [...tokens,k+'[]'], arrayTrail);
            } else {
              walk(v, [...tokens,k], arrayTrail);
            }
          } else {
            // scalar field
            // Holder is the nearest object inside an array; record is the OUTERMOST array ancestor.
            const trail = arrayTrail.slice(); // e.g., ['users','role_members']
            const holderName = trail.length ? trail[trail.length-1] : '(root)';
            const recordName = trail.length ? trail[0] : '(root)';
            out.push({
              key: k,
              sample: v,
              context: trail.length ? `${trail.join(' › ')}` : '(root)',
              holderName,
              recordName,
              // for resolution later we also keep functions:
              resolver: makeResolver(tokens, k, trail)
            });
          }
        }
      }
    }

    // Build a resolver that can enumerate matches + row objects without showing raw paths
    function makeResolver(tokens, leafKey, trail){
      return function resolveAll(rootObj){
        const results = [];
        function dive(node, idx, seenTrail){
          if (idx >= tokens.length) return;
          const token = tokens[idx];
          if (token.endsWith('[]')){ // array
            const key = token.replace('[]','').replace('[*]','');
            const arr = node?.[key];
            if (Array.isArray(arr)){
              for (const el of arr){
                if (el && typeof el==='object') dive(el, idx+1, seenTrail.concat(key));
              }
            }
          } else if (token){ // object step
            const next = node?.[token];
            if (next && typeof next === 'object'){
              dive(next, idx+1, seenTrail);
            }
          } else {
            // no-op
          }
        }
        function collectHolders(node, idx, seenTrail){
          // traverse down; when at object that has leafKey (scalar), record a match
          if (node && typeof node==='object'){
            if (Object.prototype.hasOwnProperty.call(node, leafKey) && (node[leafKey]===null || typeof node[leafKey] !== 'object')){
              // compute holder + record (outermost)
              const holder = node;
              const record = findOutermostRecordFor(holder, rootObj, trail[0]); // outermost by first trail name
              results.push({ value: node[leafKey], holder, record });
            }
            for (const [k,v] of Object.entries(node)){
              if (v && typeof v==='object') collectHolders(v, idx+1, seenTrail);
            }
          } else if (Array.isArray(node)){
            for (const el of node) collectHolders(el, idx, seenTrail);
          }
        }
        // A simpler pass: just collect across entire tree
        collectHolders(rootObj, 0, []);
        return results;
      };
    }

    function findOutermostRecordFor(holderObj, rootObj, recordName){
      // BFS to find the nearest ancestor object that lives inside the OUTERMOST array with name recordName
      // For simplicity (and performance), we’ll re-walk from root and keep parents.
      let found = null;
      function walkParents(node, parentStack){
        if (found) return;
        if (node === holderObj){
          // climb up stack to find ancestor that sits under recordName array
          for (let i = parentStack.length-1; i>=0; i--){
            const p = parentStack[i];
            if (p && p.arrayName === recordName && p.item){
              found = p.item; break;
            }
          }
          return;
        }
        if (Array.isArray(node)){
          // not labeled; climb into elements
          for (const el of node) walkParents(el, parentStack);
        } else if (node && typeof node === 'object'){
          for (const [k,v] of Object.entries(node)){
            if (Array.isArray(v)){
              for (const el of v){
                if (el && typeof el==='object'){
                  walkParents(el, parentStack.concat({arrayName:k, item:el}));
                }
              }
            } else if (v && typeof v==='object'){
              walkParents(v, parentStack);
            }
          }
        }
      }
      walkParents(rootObj, []);
      return found || holderObj;
    }

    // start traversal from root with token '$'
    walk(root, [], []);
    // Collapse duplicates by (key+context) so the list is simple
    const seen = new Map(); // key 'key|context' -> entry
    for (const e of out){
      const id = `${e.key}|${e.context}`;
      if (!seen.has(id)) seen.set(id, e);
    }
    return [...seen.values()];
  }

  // ---- UI renderers
  function renderFieldList(){
    fieldList.innerHTML='';
    filteredEntries.forEach((e, idx)=>{
      const item = document.createElement('div');
      item.className = 'item' + (selectedField===e ? ' active' : '');
      const left = document.createElement('div');
      left.style.flex = '1 1 auto';
      left.innerHTML = `<div class="name">${esc(e.key)}</div><div class="sample">e.g. ${esc(String(e.sample).slice(0,90))}</div>`;
      const right = document.createElement('div');
      right.innerHTML = `<span class="badge">${esc(e.context)}</span>`;
      item.appendChild(left); item.appendChild(right);
      item.addEventListener('click', ()=>{ selectedField = e; onFieldChosen(); });
      fieldList.appendChild(item);
    });
    fieldCount.textContent = filteredEntries.length ? `${filteredEntries.length} field(s)` : 'No fields found yet.';
  }

  function onFieldChosen(){
    // infer record + nested names from selection
    recordHint.textContent = selectedField ? `Record: ${selectedField.recordName}` : '';
    nestedLabel.textContent = selectedField ? `(${selectedField.holderName})` : '';

    // Resolve a sample of row objects to detect fields
    const matches = selectedField.resolver(root);
    const recs = []; const holders = [];
    for (let i=0;i<Math.min(matches.length, 60);i++){
      recs.push(matches[i].record);
      holders.push(matches[i].holder);
    }
    recFields = detectScalarKeys(recs);
    nestFields = detectScalarKeys(holders);

    // Reset selections (no defaults)
    selRec.clear(); selNest.clear();

    renderChipGrid(recGrid, recFields, selRec);
    renderChipGrid(nestGrid, nestFields, selNest);

    // Unique-by options from record fields (no default)
    uniqueBy.innerHTML = '';
    recFields.forEach(f=>{ const o=document.createElement('option'); o.value=f; o.textContent=f; uniqueBy.appendChild(o); });
    uniqueBy.disabled = false;

    enableRun();
  }

  function detectScalarKeys(objects){
    const keys = new Set();
    objects.forEach(o=>{
      if (!o || typeof o!=='object') return;
      Object.entries(o).forEach(([k,v])=>{
        if (v===null || typeof v!=='object') keys.add(k);
      });
    });
    return [...keys];
  }

  function renderChipGrid(container, fields, selSet){
    container.innerHTML='';
    fields.forEach(name=>{
      const lbl=document.createElement('label'); lbl.className='chip';
      const cb=document.createElement('input'); cb.type='checkbox';
      cb.checked = selSet.has(name);
      cb.addEventListener('change',()=>{ cb.checked ? selSet.add(name) : selSet.delete(name); });
      const span=document.createElement('span'); span.textContent=name;
      lbl.appendChild(cb); lbl.appendChild(span);
      container.appendChild(lbl);
    });
  }

  function buildTable(rows, cols){
    resultsBody.innerHTML=''; theadRow.innerHTML='';
    if (!rows.length){ resultsTable.style.display='none'; return; }
    cols.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; theadRow.appendChild(th); });
    const frag=document.createDocumentFragment();
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      tr.innerHTML = cols.map(c => `<td>${esc(r[c])}</td>`).join('');
      frag.appendChild(tr);
    });
    resultsBody.appendChild(frag);
    resultsTable.style.display='';
  }

  function toCsv(rows, cols){
    const header=cols.join(',');
    const lines=[header];
    for(const r of rows){
      const fields=cols.map(c=>{
        const s = r[c]==null ? '' : String(r[c]);
        return /[",\r\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
      });
      lines.push(fields.join(','));
    }
    return lines.join('\r\n');
  }

  // ---- Actions
  function run(){
    const allowed = valuesSet(valuesInput.value, ci.checked);
    const exactMatch = exact.checked;
    const perMatch = modeMatch.checked;

    const t0 = performance.now();
    const matches = selectedField.resolver(root).filter(m => matchesAllowed(allowed, m.value, {lower:ci.checked, exact:exactMatch}));

    const rows = [];
    const colsSet = new Set();

    if (perMatch){
      // One row per matching holder; include selected record + nested fields
      for (const m of matches){
        const out = {};
        selRec.forEach(k => { out[k] = valToCell(m.record?.[k]); colsSet.add(k); });
        selNest.forEach(k => { const col = `${selectedField.holderName}_${k}`; out[col] = valToCell(m.holder?.[k]); colsSet.add(col); });
        // always include filter value to trace
        out['filter_value'] = valToCell(m.value); colsSet.add('filter_value');
        rows.push(out);
      }
    } else {
      // One row per record (aggregate nested matches into a single cell)
      // group by object identity; to keep simple, stringify a stable key if possible
      const groups = new Map(); // key -> {record, holders:[]}
      for (const m of matches){
        const key = stableKey(m.record);
        if (!groups.has(key)) groups.set(key, {record:m.record, holders:[]});
        groups.get(key).holders.push(m.holder);
      }
      for (const {record, holders} of groups.values()){
        const out = {};
        selRec.forEach(k => { out[k] = valToCell(record?.[k]); colsSet.add(k); });
        // aggregate selected nested fields as readable list
        const pieces = holders.map(h=>{
          if (!selNest.size) return String(valToCell(h?.[selectedField.key])); // if nothing selected, at least show the filtered field
          const parts = [];
          selNest.forEach(k=>{
            const label = (k===selectedField.key ? '' : `${k}: `);
            parts.push(label + String(valToCell(h?.[k])));
          });
          return parts.join(', ');
        });
        const aggCol = `matches_${selectedField.holderName}`;
        out[aggCol] = pieces.join('; ');
        colsSet.add(aggCol);
        rows.push(out);
      }
    }

    const cols = [...colsSet];
    lastRows = rows; lastCols = cols;
    buildTable(rows, cols);

    const t1 = performance.now();
    // Stats
    if (perMatch){
      const uniqVals = new Set(rows.map(r => r['filter_value'])).size;
      let msg = `Rows: ${rows.length.toLocaleString()} • Unique filter values: ${uniqVals.toLocaleString()} — ${(t1-t0).toFixed(1)}ms.`;
      const uniqField = uniqueBy.value;
      if (uniqField){
        const uniqRecs = new Set(matches.map(m => String(m.record?.[uniqField]))).size;
        msg = `Rows: ${rows.length.toLocaleString()} • Unique ${uniqField}: ${uniqRecs.toLocaleString()} • Unique filter values: ${uniqVals.toLocaleString()} — ${(t1-t0).toFixed(1)}ms.`;
      }
      setStatus(msg,'ok');
    } else {
      setStatus(`Matched ${rows.length.toLocaleString()} record(s) — ${(t1-t0).toFixed(1)}ms.`,'ok');
    }

    setDownloads(rows.length>0);
  }

  function valToCell(v){
    if (v===null || v===undefined) return '';
    if (typeof v==='object') return JSON.stringify(v);
    return v;
  }
  function stableKey(obj){
    // Prefer id/email; fall back to JSON string
    if (obj && (obj.id!==undefined || obj.email!==undefined)) return `id:${obj.id}|email:${obj.email}`;
    try{ return JSON.stringify(obj);}catch{ return String(obj); }
  }

  // ---- Load & init
  function loadAndIndex(text){
    root = JSON.parse(text);
    // Build entries
    fieldEntries = collectFieldsWithContext(root);
    filteredEntries = fieldEntries;
    renderFieldList();
    setStatus(`Scanned ${fieldEntries.length} field(s). Select a field, row mode, outputs, and run.`, 'ok');
    enableRun();
  }

  function collectFieldsWithContext(rootObj){
    const out = [];
    function walk(node, pathStack, arrayTrail){
      if (node===null || node===undefined) return;
      if (Array.isArray(node)){
        const last = pathStack[pathStack.length-1] || '';
        const arrName = last.replace(/\[\]|\[\*\]/g,'') || '(array)';
        for (const el of node){
          if (el && typeof el==='object') walk(el, pathStack, arrayTrail.concat(arrName));
        }
      } else if (typeof node==='object'){
        for (const [k,v] of Object.entries(node)){
          if (v && typeof v==='object'){
            if (Array.isArray(v)){
              walk(v, pathStack.concat(k+'[]'), arrayTrail);
            } else {
              walk(v, pathStack.concat(k), arrayTrail);
            }
          } else {
            const trail = arrayTrail.slice();
            const holderName = trail.length ? trail[trail.length-1] : '(root)';
            const recordName = trail.length ? trail[0] : '(root)';
            const tokens = pathStack.slice(); // for resolver
            const entry = {
              key:k,
              sample:v,
              context: trail.length ? `${trail.join(' › ')}` : '(root)',
              holderName, recordName,
              resolver: makeResolver(tokens, k, recordName)
            };
            out.push(entry);
          }
        }
      }
    }
    function makeResolver(tokens, leafKey, recordName){
      return function resolveAll(rootObj){
        const results = [];
        function walk2(node, parents){
          if (node && typeof node==='object'){
            if (Object.prototype.hasOwnProperty.call(node, leafKey) && (node[leafKey]===null || typeof node[leafKey] !== 'object')){
              const holder = node;
              const record = findRecordAncestor(parents, recordName) || holder;
              results.push({ value: node[leafKey], holder, record });
            }
            for (const [k,v] of Object.entries(node)){
              if (Array.isArray(v)){
                for (const el of v){
                  if (el && typeof el==='object'){
                    walk2(el, parents.concat({name:k, obj:el}));
                  }
                }
              } else if (v && typeof v==='object'){
                walk2(v, parents);
              }
            }
          } else if (Array.isArray(node)){
            for (const el of node) walk2(el, parents);
          }
        }
        function findRecordAncestor(parents, recordName){
          // outermost match of the first array name we saw (recordName)
          for (let i=0;i<parents.length;i++){
            if (parents[i].name === recordName) return parents[i].obj;
          }
          return null;
        }
        walk2(rootObj, []);
        return results;
      }
    }
    walk(rootObj, [], []);
    // dedupe by field name + context
    const seen = new Map();
    for (const e of out){
      const id = `${e.key}|${e.context}`;
      if (!seen.has(id)) seen.set(id, e);
    }
    // Sort by name then context
    return
