<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>JSON Filter</title>
<style>
  :root{--bg:#0b0b10;--panel:#131320;--muted:#9aa0ac;--text:#e9e9f1;--accent:#5b8cff;--stroke:#202036;--field:#0f0f19;--ok:#2ecc71;--err:#ff5c5c}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:32px auto;padding:0 16px}
  .card{background:var(--panel);border:1px solid var(--stroke);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
  header{padding:18px;border-bottom:1px solid var(--stroke);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  header h1{margin:0;font-size:18px}
  header .sub{color:var(--muted);font-size:13px}
  .content{display:grid;grid-template-columns:1fr 1fr;gap:18px;padding:18px}
  .content.single{grid-template-columns:1fr}
  @media(max-width:980px){.content{grid-template-columns:1fr}}
  .section{display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:13px;color:var(--muted)}
  textarea,input[type=text],select{width:100%;padding:12px;border-radius:12px;border:1px solid var(--stroke);background:var(--field);color:var(--text)}
  textarea{min-height:220px;resize:vertical}
  input[type=file]{font-size:13px;max-width:100%}
  .btn{appearance:none;border:none;padding:10px 14px;border-radius:12px;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
  .btn.secondary{background:#2a2a44;color:#d9d9e6}
  .btn.ghost{background:transparent;border:1px solid var(--stroke);color:var(--text)}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .hint{font-size:12px;color:var(--muted)}
  .status{font-size:13px;margin-top:6px}
  .status.ok{color:var(--ok)} .status.err{color:var(--err);white-space:pre-wrap}
  .group{border:1px solid var(--stroke);border-radius:12px;padding:12px;background:#0f0f19}
  .group h3{margin:0 0 8px 0;font-size:13px;color:#bdbdd3}
  .picker-body{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media(max-width:980px){.picker-body{grid-template-columns:1fr}}
  .fieldlist{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:8px;max-height:240px;overflow:auto;padding:8px;background:#0c0c16;border:1px solid #1e1e33;border-radius:10px}
  .fieldchip{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:10px;background:#101022;border:1px solid #232345;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:13px;color:#d6d6e6}
  table{width:100%;border-collapse:separate;border-spacing:0;background:var(--field);border:1px solid var(--stroke);border-radius:12px;overflow:hidden}
  th,td{padding:10px 12px;border-bottom:1px solid #1e1e30;text-align:left;vertical-align:top}
  th{background:#101022;font-size:12px;color:#bdbdd3;position:sticky;top:0}
  tr:last-child td{border-bottom:none}
  .footer{padding:12px 18px;border-top:1px solid var(--stroke);display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between}
  code.bubble{background:#101022;padding:2px 6px;border-radius:8px;border:1px solid #232345;font-family:ui-monospace,Consolas,Menlo,monospace}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <h1>JSON Filter</h1>
      <div class="sub">No installs • Everything runs locally</div>
    </header>

    <div class="content">
      <!-- left: load -->
      <div class="section">
        <label>1) Load JSON (choose one):</label>
        <div class="row">
          <input id="fileInput" type="file" accept=".json,application/json"/>
          <button class="btn ghost" id="clearBtn">Clear</button>
        </div>
        <textarea id="jsonText" placeholder='Paste any JSON here (object or array).'></textarea>
        <div class="hint">Tip: file picker is faster for very large files.</div>

        <div class="group">
          <h3>2) Pick your <em>record set</em> (where rows come from)</h3>
          <div class="row">
            <select id="recordSetSelect" title="Array/object-of-objects path"></select>
            <button class="btn ghost" id="rescanBtn" title="Rescan JSON for candidates">Rescan</button>
          </div>
          <div class="hint">We auto-detect arrays of objects anywhere in the JSON (and object-of-objects). Choose the one that represents your rows.</div>
        </div>
      </div>

      <!-- right: filter + output -->
      <div class="section">
        <label>3) Filter & Output</label>

        <div class="group">
          <h3>Filter</h3>
          <div class="row">
            <label><input type="radio" name="scope" id="scopeRecord" checked> Filter by <code class="bubble">record</code> field</label>
            <label><input type="radio" name="scope" id="scopeNested"> Filter by <code class="bubble">nested collection</code> field</label>
          </div>

          <div class="row" id="recordScopeRow">
            <select id="recordFieldSelect" title="Record field to match"></select>
          </div>

          <div id="nestedScopeBlock">
            <div class="row">
              <select id="collectionSelect" title="Nested collection under each record"></select>
              <select id="nestedFieldSelect" title="Field within that collection"></select>
            </div>
            <div class="row">
              <label><input id="explodeRows" type="checkbox"> One row per match (flatten)</label>
              <select id="uniqueBySelect" title="Unique record id for counts"></select>
            </div>
          </div>

          <div class="row">
            <input id="valuesInput" type="text" placeholder="Values to match (comma-separated)">
          </div>
          <div class="row">
            <label><input id="caseInsensitive" type="checkbox"> Case-insensitive</label>
            <label><input id="exactMatch" type="checkbox" checked> Exact match</label>
          </div>
        </div>

        <div class="group">
          <h3>Output fields</h3>
          <div class="picker-body">
            <div>
              <div class="hint">Record fields</div>
              <div id="recordFieldGrid" class="fieldlist"></div>
              <div class="row" style="margin-top:8px;">
                <button class="btn ghost" id="recAll">All</button>
                <button class="btn ghost" id="recNone">None</button>
                <button class="btn ghost" id="recDefaults">Defaults</button>
              </div>
            </div>
            <div>
              <div class="hint">Nested fields (<span id="nestedLabel">—</span>)</div>
              <div id="nestedFieldGrid" class="fieldlist"></div>
              <div class="row" style="margin-top:8px;">
                <button class="btn ghost" id="nestAll">All</button>
                <button class="btn ghost" id="nestNone">None</button>
                <button class="btn ghost" id="nestDefaults">Defaults</button>
              </div>
            </div>
          </div>
          <div class="hint" style="margin-top:6px">Defaults: <code class="bubble">id</code>, <code class="bubble">email</code>, <code class="bubble">display_name</code> if present; nested defaults: <code class="bubble">name</code>, <code class="bubble">account_name</code>, <code class="bubble">role</code> if present.</div>
        </div>

        <div class="row" style="gap:10px;">
          <button class="btn" id="runBtn">Run Filter</button>
          <button class="btn secondary" id="downloadJsonBtn" disabled>Download JSON</button>
          <button class="btn secondary" id="downloadCsvBtn" disabled>Download CSV</button>
          <button class="btn ghost" id="copyBtn" disabled>Copy JSON</button>
        </div>
        <div id="status" class="status"></div>
      </div>
    </div>

    <!-- results -->
    <div class="content single">
      <div class="section">
        <label>Results</label>
        <div style="overflow:auto;max-height:55vh;border-radius:12px">
          <table id="resultsTable" style="display:none;">
            <thead><tr id="theadRow"></tr></thead>
            <tbody id="resultsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="footer">
      <span class="hint">All processing is local; nothing is uploaded.</span>
    </div>
  </div>
</div>

<script>
(function(){
  // --- DOM refs
  const fileInput = document.getElementById('fileInput');
  const jsonText = document.getElementById('jsonText');
  const clearBtn = document.getElementById('clearBtn');
  const rescanBtn = document.getElementById('rescanBtn');
  const recordSetSelect = document.getElementById('recordSetSelect');

  const scopeRecord = document.getElementById('scopeRecord');
  const scopeNested = document.getElementById('scopeNested');
  const recordScopeRow = document.getElementById('recordScopeRow');
  const nestedScopeBlock = document.getElementById('nestedScopeBlock');

  const recordFieldSelect = document.getElementById('recordFieldSelect');
  const collectionSelect = document.getElementById('collectionSelect');
  const nestedFieldSelect = document.getElementById('nestedFieldSelect');
  const uniqueBySelect = document.getElementById('uniqueBySelect');

  const valuesInput = document.getElementById('valuesInput');
  const caseInsensitive = document.getElementById('caseInsensitive');
  const exactMatch = document.getElementById('exactMatch');
  const explodeRows = document.getElementById('explodeRows');

  const recordFieldGrid = document.getElementById('recordFieldGrid');
  const nestedFieldGrid = document.getElementById('nestedFieldGrid');
  const nestedLabel = document.getElementById('nestedLabel');

  const recAll = document.getElementById('recAll'), recNone = document.getElementById('recNone'), recDefaults = document.getElementById('recDefaults');
  const nestAll = document.getElementById('nestAll'), nestNone = document.getElementById('nestNone'), nestDefaults = document.getElementById('nestDefaults');

  const runBtn = document.getElementById('runBtn');
  const statusEl = document.getElementById('status');
  const resultsTable = document.getElementById('resultsTable');
  const theadRow = document.getElementById('theadRow');
  const resultsBody = document.getElementById('resultsBody');
  const downloadJsonBtn = document.getElementById('downloadJsonBtn');
  const downloadCsvBtn = document.getElementById('downloadCsvBtn');
  const copyBtn = document.getElementById('copyBtn');

  let lastOutput = [];
  let rootData = null;

  // state
  const state = {
    candidateSets: [], // {label, resolve: (root)=>records, sample, count}
    selectedSetIndex: 0,
    recordFields: [],
    nestedCollections: [], // [{name, fields}]
    selectedRecordFields: new Set(),
    selectedNestedFields: new Set()
  };

  // helpers
  const escapeHtml = v => String(v ?? '').replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
  const setStatus = (m,k)=>{statusEl.textContent=m||'';statusEl.className='status '+(k||'')};
  const setDownloads = on => {downloadJsonBtn.disabled=downloadCsvBtn.disabled=copyBtn.disabled=!on};
  const parseValues = (s,ci)=> new Set((s||'').split(',').map(x=>x.trim()).filter(Boolean).map(x=>ci?x.toLowerCase():x));
  function matchAllowed(allowed,val,{ci,exact}){
    const t = ci ? String(val??'').toLowerCase() : String(val??'');
    if (exact) return allowed.has(t);
    for (const a of allowed) if (t.includes(a)) return true;
    return false;
  }

  // find candidate record sets anywhere in JSON
  function scanCandidates(root){
    const cands = [];
    const add = (label, resolver, count, mode) => cands.push({label, resolve:resolver, count, mode});
    const seen = new Set();

    function walk(node, pathLabel, resolver){
      if (!node) return;
      if (Array.isArray(node)){
        const objs = node.filter(x => x && typeof x==='object' && !Array.isArray(x));
        if (objs.length){
          const lbl = (pathLabel||'$') + '[]';
          if (!seen.has(lbl)){ add(lbl, root=>resolver(root), objs.length, 'array'); seen.add(lbl); }
        }
        node.forEach((child,i)=> walk(child, (pathLabel||'$')+'['+i+']', r=> r(root)[i]));
      } else if (typeof node==='object'){
        // object-of-objects candidate
        const vals = Object.values(node);
        const objVals = vals.filter(v => v && typeof v==='object' && !Array.isArray(v));
        if (objVals.length && objVals.length===vals.length){
          const lbl = (pathLabel||'$') + '{values}';
          if (!seen.has(lbl)){ add(lbl, root=>Object.values(resolver(root)), objVals.length, 'objectValues'); seen.add(lbl); }
        }
        for (const [k,v] of Object.entries(node)){
          walk(v, (pathLabel?pathLabel+'.':'$.' )+k, r=> r(root)[k]);
        }
      }
    }
    walk(root, '$', _=>root);
    return cands;
  }

  function resolveRecords(){
    const cand = state.candidateSets[state.selectedSetIndex];
    if (!cand) return [];
    const recs = cand.resolve(()=>rootData);
    // only keep objects
    return (recs||[]).filter(x=>x && typeof x==='object' && !Array.isArray(x));
  }

  function detectSchema(records){
    const sampleCount = Math.min(records.length, 50);
    const unionKeys = new Set();
    const nestedMap = new Map(); // name -> Set(fields)

    for (let i=0;i<sampleCount;i++){
      const r = records[i] || {};
      Object.keys(r).forEach(k=>{
        if (Array.isArray(r[k])){
          const arr = r[k];
          const objEls = arr.filter(x=>x && typeof x==='object' && !Array.isArray(x));
          if (objEls.length){
            if (!nestedMap.has(k)) nestedMap.set(k,new Set());
            objEls.slice(0,10).forEach(o=> Object.keys(o||{}).forEach(f=> nestedMap.get(k).add(f)));
          }
        } else if (r[k] && typeof r[k]==='object'){
          // allow object-valued field to be treated as nested collection of its values if values are objects
          const vals = Object.values(r[k]);
          if (vals.length && vals.every(v=>v && typeof v==='object' && !Array.isArray(v))){
            if (!nestedMap.has(k)) nestedMap.set(k,new Set());
            vals.slice(0,10).forEach(o=> Object.keys(o||{}).forEach(f=> nestedMap.get(k).add(f)));
          } else {
            unionKeys.add(k); // keep object ref as a field, but won't be flattenable
          }
        } else {
          unionKeys.add(k);
        }
      });
    }

    state.recordFields = [...unionKeys];
    state.nestedCollections = [...nestedMap.entries()].map(([name,set])=>({name,fields:[...set]}));

    // defaults
    const defaults = ['id','email','display_name','name','title'];
    state.selectedRecordFields = new Set(state.recordFields.filter(k=>defaults.includes(k)).slice(0,3));
    const nDefaults = ['account_name','name','role'];
    state.selectedNestedFields = new Set(nDefaults);
  }

  function renderRecordSetPicker(){
    recordSetSelect.innerHTML='';
    state.candidateSets.forEach((c,idx)=>{
      const opt=document.createElement('option');
      opt.value=idx; opt.textContent=`${c.label}  — ${c.count} item(s)`;
      recordSetSelect.appendChild(opt);
    });
    recordSetSelect.value=String(state.selectedSetIndex||0);
  }

  function renderFilterSelectors(){
    // record field list
    recordFieldSelect.innerHTML='';
    state.recordFields.forEach(k=>{
      const o=document.createElement('option'); o.value=k; o.textContent=k; recordFieldSelect.appendChild(o);
    });
    // good default
    ['email','id','name','display_name','title'].some(k=>{
      if (state.recordFields.includes(k)){ recordFieldSelect.value=k; return true; }
      return false;
    });

    // unique-by list (record)
    uniqueBySelect.innerHTML='';
    const uniqCandidates = state.recordFields.filter(k=>['id','email','uid','key','slug'].includes(k)).concat(state.recordFields).filter((v,i,a)=>a.indexOf(v)===i);
    uniqCandidates.forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent='Unique by: '+k; uniqueBySelect.appendChild(o); });
    if (uniqCandidates.length) uniqueBySelect.value=uniqCandidates[0];

    // nested collection + field
    collectionSelect.innerHTML='';
    state.nestedCollections.forEach(c=>{ const o=document.createElement('option'); o.value=c.name; o.textContent=c.name; collectionSelect.appendChild(o); });
    updateNestedFieldOptions();

    nestedScopeBlock.style.display = state.nestedCollections.length ? '' : 'none';
    toggleScopeUI();
  }

  function updateNestedFieldOptions(){
    nestedFieldSelect.innerHTML='';
    const coll = state.nestedCollections.find(c=>c.name===collectionSelect.value) || state.nestedCollections[0];
    if (!coll){ nestedLabel.textContent='—'; return; }
    nestedLabel.textContent = coll.name;
    coll.fields.forEach(f=>{ const o=document.createElement('option'); o.value=f; o.textContent=f; nestedFieldSelect.appendChild(o); });
    if (coll.fields.includes('account_name')) nestedFieldSelect.value='account_name';
    else if (coll.fields.includes('name')) nestedFieldSelect.value='name';
    // refresh nested field chips
    renderFieldGrids();
  }

  function renderFieldGrids(){
    recordFieldGrid.innerHTML=''; nestedFieldGrid.innerHTML='';
    const makeChip=(name,set)=>{
      const lbl=document.createElement('label'); lbl.className='fieldchip';
      const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=set.has(name);
      cb.addEventListener('change',()=>{ cb.checked?set.add(name):set.delete(name) });
      const span=document.createElement('span'); span.textContent=name;
      lbl.appendChild(cb); lbl.appendChild(span); return lbl;
    };
    state.recordFields.forEach(k=> recordFieldGrid.appendChild(makeChip(k,state.selectedRecordFields)));
    const coll = state.nestedCollections.find(c=>c.name===collectionSelect.value);
    (coll?coll.fields:[]).forEach(k=> nestedFieldGrid.appendChild(makeChip(k,state.selectedNestedFields)));
  }

  function toggleScopeUI(){
    const nestedActive = scopeNested.checked && state.nestedCollections.length>0;
    recordScopeRow.style.display = scopeRecord.checked ? '' : 'none';
    nestedScopeBlock.style.display = nestedActive ? '' : 'none';
    explodeRows.disabled = !nestedActive;
    if (!nestedActive) explodeRows.checked = false;
  }

  function toCsv(rows, cols){
    const header=cols.join(',');
    const lines=[header];
    for(const r of rows){
      const fields=cols.map(c=>{
        const s = (r[c]==null)?'':String(r[c]);
        return /[",\r\n]/.test(s)?'"'+s.replace(/"/g,'""')+'"':s;
      });
      lines.push(fields.join(','));
    }
    return lines.join('\r\n');
  }

  function renderTable(rows, columns){
    resultsBody.innerHTML=''; theadRow.innerHTML='';
    if (!rows.length){ resultsTable.style.display='none'; return; }
    columns.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; theadRow.appendChild(th); });
    const frag=document.createDocumentFragment();
    rows.forEach(o=>{
      const tr=document.createElement('tr');
      tr.innerHTML = columns.map(c=>`<td>${escapeHtml(o[c])}</td>`).join('');
      frag.appendChild(tr);
    });
    resultsBody.appendChild(frag);
    resultsTable.style.display='';
  }

  // build rows
  function runFilter(){
    const records = resolveRecords();
    if (!records.length) return {rows:[], columns:[], stats:null};

    const allowed = parseValues(valuesInput.value, caseInsensitive.checked);
    if (!allowed.size) return {rows:[], columns:[], stats:null};

    const ci=caseInsensitive.checked, exact=exactMatch.checked;

    const recCols = [...state.selectedRecordFields];
    const nestCols = [...state.selectedNestedFields];

    let rows=[];
    let columns=[];

    if (scopeRecord.checked){
      const field = recordFieldSelect.value;
      rows = records.filter(r=> matchAllowed(allowed, r?.[field], {ci,exact}))
                    .map(r=>{
                      const obj={}; recCols.forEach(k=> obj[k]= r?.[k] ?? null );
                      return obj;
                    });
      columns = recCols;
      return {rows, columns, stats: {rows:rows.length}};
    }

    // nested
    const collName = collectionSelect.value;
    const nestedField = nestedFieldSelect.value;

    if (explodeRows.checked){
      for (const r of records){
        const items = toNestedItems(r[collName]);
        const matches = items.filter(it=> matchAllowed(allowed, it?.[nestedField], {ci,exact}));
        for (const m of matches){
          const obj={};
          recCols.forEach(k=> obj[k]=r?.[k] ?? null);
          // ensure filter field exists
          obj[`${collName}_${nestedField}`] = m?.[nestedField] ?? null;
          nestCols.forEach(k=> obj[`${collName}_${k}`] = m?.[k] ?? null);
          rows.push(obj);
        }
      }
      const columnsSet = new Set([...recCols, `${collName}_${nestedField}`, ...nestCols.map(k=>`${collName}_${k}`)]);
      columns=[...columnsSet];

      // stats: unique records + unique filter values
      const uniqByField = uniqueBySelect.value;
      const uniqRecords = new Set(rows.map(r=> r[uniqByField])).size;
      const uniqVals = new Set(rows.map(r=> r[`${collName}_${nestedField}`])).size;
      return {rows, columns, stats:{rows:rows.length, uniqRecords, uniqVals, uniqField:uniqByField, valueField:`${collName}_${nestedField}`}};
    } else {
      for (const r of records){
        const items = toNestedItems(r[collName]);
        const matches = items.filter(it=> matchAllowed(allowed, it?.[nestedField], {ci,exact}));
        if (!matches.length) continue;
        const obj={}; recCols.forEach(k=> obj[k]=r?.[k] ?? null);
        obj[`matching_${collName}`] = matches.map(m=>{
          if (!nestCols.length) return String(m?.[nestedField] ?? '');
          const parts=[];
          if (m?.[nestedField]!=null) parts.push(String(m[nestedField]));
          const extras = nestCols.filter(k=>k!==nestedField).map(k=> m?.[k]!=null ? `${k}:${m[k]}` : '').filter(Boolean);
          if (extras.length) parts.push(`(${extras.join(', ')})`);
          return parts.join(' ');
        }).join('; ');
        rows.push(obj);
      }
      columns=[...recCols, `matching_${collName}`];
      return {rows, columns, stats:{rows:rows.length}};
    }
  }

  function toNestedItems(x){
    if (Array.isArray(x)) return x.filter(o=>o && typeof o==='object' && !Array.isArray(o));
    if (x && typeof x==='object'){
      const vals = Object.values(x);
      if (vals.length && vals.every(v=>v && typeof v==='object' && !Array.isArray(v))) return vals;
    }
    return [];
  }

  // events
  function loadAndDetect(text){
    rootData = JSON.parse(text);
    state.candidateSets = scanCandidates(rootData);
    if (!state.candidateSets.length){ setStatus('No array/object-of-objects of records found. Paste different JSON or expand nested areas.', 'err'); return; }
    state.selectedSetIndex = 0;
    renderRecordSetPicker();

    const records = resolveRecords();
    detectSchema(records);
    renderFilterSelectors();
    renderFieldGrids();
    setStatus(`Detected ${records.length.toLocaleString()} record(s) from ${state.candidateSets[0].label}.`, 'ok');
  }

  fileInput.addEventListener('change', async e=>{
    const f=e.target.files?.[0]; if(!f) return;
    try{ const t=await f.text(); jsonText.value=t; loadAndDetect(t); }
    catch(err){ setStatus('Failed to read file: '+String(err),'err'); }
  });

  rescanBtn.addEventListener('click', ()=>{
    try{ const raw=(jsonText.value||'').trim(); if(!raw) return setStatus('Paste JSON or load a file first.','err'); loadAndDetect(raw); }
    catch(e){ setStatus('Invalid JSON: '+e.message,'err'); }
  });

  jsonText.addEventListener('blur', ()=>{
    try{ const raw=(jsonText.value||'').trim(); if(!raw) return; loadAndDetect(raw); }catch(_){}
  });

  recordSetSelect.addEventListener('change', ()=>{
    state.selectedSetIndex = Number(recordSetSelect.value)||0;
    const records = resolveRecords();
    detectSchema(records);
    renderFilterSelectors();
    renderFieldGrids();
    setStatus(`Record set switched: ${records.length.toLocaleString()} record(s).`,'ok');
  });

  collectionSelect.addEventListener('change', ()=>{ updateNestedFieldOptions(); });
  scopeRecord.addEventListener('change', toggleScopeUI);
  scopeNested.addEventListener('change', toggleScopeUI);

  recAll.addEventListener('click', ()=>{ state.selectedRecordFields=new Set(state.recordFields); renderFieldGrids(); });
  recNone.addEventListener('click', ()=>{ state.selectedRecordFields=new Set(); renderFieldGrids(); });
  recDefaults.addEventListener('click', ()=>{
    const defs=['id','email','display_name','name','title'];
    state.selectedRecordFields=new Set(state.recordFields.filter(k=>defs.includes(k)).slice(0,3));
    renderFieldGrids();
  });
  nestAll.addEventListener('click', ()=>{
    const coll=state.nestedCollections.find(c=>c.name===collectionSelect.value);
    state.selectedNestedFields=new Set(coll?coll.fields:[]);
    renderFieldGrids();
  });
  nestNone.addEventListener('click', ()=>{ state.selectedNestedFields=new Set(); renderFieldGrids(); });
  nestDefaults.addEventListener('click', ()=>{
    const defs=['name','account_name','role'];
    const coll=state.nestedCollections.find(c=>c.name===collectionSelect.value);
    state.selectedNestedFields=new Set((coll?coll.fields:[]).filter(k=>defs.includes(k)));
    renderFieldGrids();
  });

  clearBtn.addEventListener('click', ()=>{
    fileInput.value=''; jsonText.value=''; rootData=null; state.candidateSets=[]; recordSetSelect.innerHTML='';
    state.recordFields=[]; state.nestedCollections=[]; recordFieldGrid.innerHTML=''; nestedFieldGrid.innerHTML='';
    resultsBody.innerHTML=''; theadRow.innerHTML=''; resultsTable.style.display='none'; setDownloads(false); setStatus('');
  });

  runBtn.addEventListener('click', ()=>{
    if (!rootData) return setStatus('Load JSON first.', 'err');
    const {rows, columns, stats} = runFilter();
    if (!rows.length){ setStatus('No matches.', 'ok'); resultsTable.style.display='none'; setDownloads(false); return; }
    lastOutput = rows; renderTable(rows, columns); setDownloads(true);
    if (stats && stats.uniqRecords!=null){
      setStatus(`Rows: ${stats.rows.toLocaleString()} • Unique records (${stats.uniqField}): ${stats.uniqRecords.toLocaleString()} • Unique values (${stats.valueField}): ${stats.uniqVals.toLocaleString()}`, 'ok');
    } else {
      setStatus(`Matched ${rows.length.toLocaleString()} row(s).`, 'ok');
    }
  });

  downloadJsonBtn.addEventListener('click', ()=>{
    if (!lastOutput.length) return;
    const blob = new Blob([JSON.stringify(lastOutput,null,2)],{type:'application/json'});
    trigger(blob,'filtered-output.json');
  });
  downloadCsvBtn.addEventListener('click', ()=>{
    if (!lastOutput.length) return;
    const cols = Array.from(theadRow.querySelectorAll('th')).map(th=>th.textContent);
    const csv = toCsv(lastOutput, cols);
    trigger(new Blob([csv],{type:'text/csv;charset=utf-8'}),'filtered-output.csv');
  });
  copyBtn.addEventListener('click', async()=>{
    if (!lastOutput.length) return;
    try{ await navigator.clipboard.writeText(JSON.stringify(lastOutput,null,2)); setStatus('Copied JSON to clipboard.','ok'); }
    catch(e){ setStatus('Copy failed: '+e.message,'err'); }
  });
  function trigger(blob,name){const url=URL.createObjectURL(blob);const a=document.createElement('a');a.href=url;a.download=name;document.body.appendChild(a);a.click();setTimeout(()=>{URL.revokeObjectURL(url);a.remove();},0)}
})();
</script>
</body>
</html>
