<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flexible JSON Filter — Simple UI (fixed outputs)</title>
<style>
  :root{--bg:#0b0b10;--panel:#131320;--muted:#9aa0ac;--text:#e9e9f1;--accent:#5b8cff;--stroke:#202036;--field:#0f0f19;--ok:#2ecc71;--err:#ff5c5c}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:32px auto;padding:0 16px}
  .card{background:var(--panel);border:1px solid var(--stroke);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
  header{padding:18px;border-bottom:1px solid var(--stroke);display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  header h1{margin:0;font-size:18px}
  header .sub{color:var(--muted);font-size:13px}
  .content{display:grid;grid-template-columns:1fr 1fr;gap:18px;padding:18px}
  .content.single{grid-template-columns:1fr}
  @media(max-width:980px){.content{grid-template-columns:1fr}}
  .section{display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:13px;color:var(--muted)}
  textarea,input[type=text],select{width:100%;padding:12px;border-radius:12px;border:1px solid var(--stroke);background:var(--field);color:var(--text)}
  textarea{min-height:220px;resize:vertical}
  input[type=file]{font-size:13px;max-width:100%}
  .btn{appearance:none;border:none;padding:10px 14px;border-radius:12px;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
  .btn.secondary{background:#2a2a44;color:#d9d9e6}
  .btn.ghost{background:transparent;border:1px solid var(--stroke);color:var(--text)}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .hint{font-size:12px;color:var(--muted)}
  .status{font-size:13px;margin-top:6px}
  .status.ok{color:var(--ok)} .status.err{color:var(--err);white-space:pre-wrap}
  .group{border:1px solid var(--stroke);border-radius:12px;padding:12px;background:#0f0f19}
  .group h3{margin:0 0 8px 0;font-size:13px;color:#bdbdd3}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media(max-width:980px){.two{grid-template-columns:1fr}}
  .listbox{width:100%;min-height:220px;max-height:260px;overflow:auto;padding:0;margin:0;border:1px solid #1e1e33;border-radius:10px;background:#0c0c16}
  .listbox option{padding:10px 12px;border-bottom:1px solid #17172a}
  .chiplist{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:8px;max-height:240px;overflow:auto;padding:8px;background:#0c0c16;border:1px solid #1e1e33;border-radius:10px}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:10px;background:#101022;border:1px solid #232345;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:13px;color:#d6d6e6}
  table{width:100%;border-collapse:separate;border-spacing:0;background:var(--field);border:1px solid var(--stroke);border-radius:12px;overflow:hidden}
  th,td{padding:10px 12px;border-bottom:1px solid #1e1e30;text-align:left;vertical-align:top}
  th{background:#101022;font-size:12px;color:#bdbdd3;position:sticky;top:0}
  tr:last-child td{border-bottom:none}
  .footer{padding:12px 18px;border-top:1px solid var(--stroke);display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between}
  code.bubble{background:#101022;padding:2px 6px;border-radius:8px;border:1px solid #232345;font-family:ui-monospace,Consolas,Menlo,monospace}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <h1>Flexible JSON Filter</h1>
      <div class="sub">Local only • no defaults</div>
    </header>

    <div class="content">
      <!-- LOAD -->
      <div class="section">
        <label>1) Load JSON (choose one):</label>
        <div class="row">
          <input id="fileInput" type="file" accept=".json,application/json"/>
          <button class="btn ghost" id="clearBtn">Clear</button>
        </div>
        <textarea id="jsonText" placeholder="Paste any JSON (object or array)"></textarea>
        <div class="hint">File picker is faster for very large files.</div>
      </div>

      <!-- BUILDER -->
      <div class="section">
        <label>2) Build your query (filter + row mode + outputs)</label>

        <div class="group">
          <h3>Filter field</h3>
          <div class="two">
            <input id="fieldSearch" type="text" placeholder="Search fields… e.g. account_name, email, id">
            <label class="row" style="gap:8px;"><input id="showPaths" type="checkbox"> <span class="hint">Show full JSON paths</span></label>
          </div>
          <select id="fieldList" size="10" class="listbox" title="Pick a field to filter"></select>
          <div class="two">
            <input id="valuesInput" type="text" placeholder="Values (comma-separated)">
            <div class="row">
              <label><input id="caseInsensitive" type="checkbox"> Case-insensitive</label>
              <label><input id="exactMatch" type="checkbox"> Exact match</label>
            </div>
          </div>
          <div class="hint">Items are shown as <code class="bubble">collection.chain.field</code> with a sample value. Paths are hidden unless toggled.</div>
        </div>

        <div class="group">
          <h3>Row mode</h3>
          <div class="row">
            <label><input type="radio" name="rowmode" id="modeMatch"> Per match (flatten)</label>
            <label><input type="radio" name="rowmode" id="modeParent"> Per parent (aggregate)</label>
          </div>
          <div class="hint">“Parent” = the nearest list ancestor of the matching item (e.g., the user above their role_members). No ancestor dropdown.</div>
        </div>

        <div class="group" id="outputsGroup">
          <h3>Output fields</h3>
          <div class="row">
            <strong>Row fields</strong>
            <button class="btn ghost" id="rowAll">All</button>
            <button class="btn ghost" id="rowNone">None</button>
          </div>
          <div id="rowFieldGrid" class="chiplist"></div>

          <div id="matchBlock" style="margin-top:12px;">
            <div class="row" style="margin-top:8px;">
              <strong>Matched item fields</strong>
              <span class="hint">(only if filtering inside a nested list)</span>
              <button class="btn ghost" id="matchAll">All</button>
              <button class="btn ghost" id="matchNone">None</button>
            </div>
            <div id="matchFieldGrid" class="chiplist"></div>
          </div>
        </div>

        <div class="row" style="gap:10px;">
          <button class="btn" id="runBtn" disabled>Run</button>
          <button class="btn secondary" id="downloadJsonBtn" disabled>Download JSON</button>
          <button class="btn secondary" id="downloadCsvBtn" disabled>Download CSV</button>
          <button class="btn ghost" id="copyBtn" disabled>Copy JSON</button>
        </div>
        <div id="status" class="status"></div>
      </div>
    </div>

    <!-- RESULTS -->
    <div class="content single">
      <div class="section">
        <label>Results</label>
        <div style="overflow:auto;max-height:55vh;border-radius:12px">
          <table id="resultsTable" style="display:none;">
            <thead><tr id="theadRow"></tr></thead>
            <tbody id="resultsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="footer">
      <span class="hint">Everything runs locally.</span>
      <span class="hint">If you want wildcard search next, say the word.</span>
    </div>
  </div>
</div>

<script>
(function(){
  // --- DOM
  const fileInput=document.getElementById('fileInput'), jsonText=document.getElementById('jsonText'), clearBtn=document.getElementById('clearBtn');
  const fieldSearch=document.getElementById('fieldSearch'), showPaths=document.getElementById('showPaths'), fieldList=document.getElementById('fieldList');
  const valuesInput=document.getElementById('valuesInput'), caseInsensitive=document.getElementById('caseInsensitive'), exactMatch=document.getElementById('exactMatch');
  const modeMatch=document.getElementById('modeMatch'), modeParent=document.getElementById('modeParent');
  const outputsGroup=document.getElementById('outputsGroup'), matchBlock=document.getElementById('matchBlock');
  const rowFieldGrid=document.getElementById('rowFieldGrid'), matchFieldGrid=document.getElementById('matchFieldGrid');
  const rowAll=document.getElementById('rowAll'), rowNone=document.getElementById('rowNone'), matchAll=document.getElementById('matchAll'), matchNone=document.getElementById('matchNone');
  const runBtn=document.getElementById('runBtn'), statusEl=document.getElementById('status'), resultsTable=document.getElementById('resultsTable'), theadRow=document.getElementById('theadRow'), resultsBody=document.getElementById('resultsBody');
  const downloadJsonBtn=document.getElementById('downloadJsonBtn'), downloadCsvBtn=document.getElementById('downloadCsvBtn'), copyBtn=document.getElementById('copyBtn');

  // --- State
  let root=null;
  let entries=[];           // field entries across JSON
  let filteredEntries=[];
  let selectedEntry=null;   // current filter field entry
  let selectedRowFields=new Set();
  let selectedMatchFields=new Set();
  let lastRows=[], lastCols=[];

  // --- Utils
  const esc=v=>String(v??'').replace(/[&<>"']/g,s=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
  const setStatus=(m,k)=>{statusEl.textContent=m||'';statusEl.className='status '+(k||'')}
  const setDownloads=on=>{downloadJsonBtn.disabled=downloadCsvBtn.disabled=copyBtn.disabled=!on}
  const enableRun=()=>{ runBtn.disabled = !(root && selectedEntry && valuesInput.value.trim() && (modeMatch.checked || modeParent.checked)); }
  const parseVals=(s,ci)=>new Set((s||'').split(',').map(x=>x.trim()).filter(Boolean).map(x=>ci?x.toLowerCase():x));
  const matchAllowed=(allowed,val,{ci,exact})=>{const t=ci?String(val??'').toLowerCase():String(val??'');if(exact)return allowed.has(t);for(const a of allowed)if(t.includes(a))return true;return false;}

  // Path helpers
  const isColl=tok=>/\[\]|\[\*\]$/.test(tok);
  const base=tok=>tok.replace(/\[\]|\[\*\]/,'');
  const tokensOf=p=>p.split('.');

  // Scan all scalar fields (with context)
  function scanFields(root){
    const out=[];
    function walk(node, toks, listAnc){
      if (node==null) return;
      if (Array.isArray(node)){
        for(const el of node) walk(el, toks, isColl(toks[toks.length-1]||'') ? listAnc.concat([toks.join('.')]) : listAnc);
      } else if (typeof node==='object'){
        const parentTok=toks[toks.length-1]||'$';
        const newAnc = isColl(parentTok) ? listAnc.concat([toks.join('.')]) : listAnc;
        for(const [k,v] of Object.entries(node)){
          const next = toks.length? toks.concat([k]) : ['$.',k];
          if (v && typeof v==='object'){
            if (Array.isArray(v)) walk(v, [...next.slice(0,-1), next[next.length-1]+'[]'], newAnc);
            else walk(v, next, newAnc);
          } else {
            // scalar
            const path=(toks.length? toks.join('.')+'.':'$.' )+k;
            const lastCollIdx = [...toks, k].reduce((acc,t,i)=>isColl(t)?i:acc,-1);
            const prevCollIdx = [...toks, k].reduce((acc,t,i)=>isColl(t)?(i<lastCollIdx?i:acc):acc,-1);
            const holderColl = lastCollIdx>=0 ? [...toks, k].slice(0,lastCollIdx+1).join('.') : toks.join('.');
            const parentColl = prevCollIdx>=0 ? [...toks, k].slice(0,prevCollIdx+1).join('.') : holderColl;
            const chain = (path.replace(/^\$\./,'').replace(/\[\]|\[\*\]/g,''));
            out.push({
              path, sample:v,
              holderColl, parentColl,
              chainLabel: chain
            });
          }
        }
      }
    }
    walk(root, ['$'], []);
    // dedupe by path
    const seen=new Set(); return out.filter(e=>{if(seen.has(e.path))return false; seen.add(e.path); return true;});
  }

  // Collect all objects at a collection path (…[]). Supports arrays and object-of-objects.
  function collectAtCollection(path){
    const toks=tokensOf(path);
    function step(nodes, idx){
      if (idx>=toks.length) return nodes;
      const tok=toks[idx];
      if (tok==='$'||tok==='$.') return step(nodes, idx+1);
      const coll=isColl(tok), key=base(tok);
      const next=[];
      for(const n of nodes){
        if (!n || typeof n!=='object') continue;
        if (coll){
          const seq=n[key];
          if (Array.isArray(seq)) seq.forEach(el=>{ if (el && typeof el==='object') next.push(el); });
          else if (seq && typeof seq==='object') Object.values(seq).forEach(el=>{ if (el && typeof el==='object') next.push(el); });
        } else {
          const obj=n[key];
          if (obj && typeof obj==='object') next.push(obj);
        }
      }
      return step(next, idx+1);
    }
    return step([root], 0);
  }

  function scalarKeysOf(objs){
    const set=new Set();
    const limit=Math.min(100, objs.length);
    for (let i=0;i<limit;i++){
      const o=objs[i]; if(!o||typeof o!=='object') continue;
      for(const [k,v] of Object.entries(o)) if (v==null || typeof v!=='object') set.add(k);
    }
    return [...set].sort();
  }

  // UI renderers
  function renderFieldList(){
    fieldList.innerHTML='';
    filteredEntries.forEach(e=>{
      const label = e.chainLabel + (showPaths.checked ? `  •  ${e.path}` : '');
      const opt=document.createElement('option');
      opt.value=e.path; opt.textContent=`${label} — sample: ${String(e.sample).slice(0,80)}`;
      fieldList.appendChild(opt);
    });
  }

  function renderChips(container, keys, setRef){
    container.innerHTML='';
    const mk=(k)=>{
      const lbl=document.createElement('label'); lbl.className='chip';
      const cb=document.createElement('input'); cb.type='checkbox';
      cb.checked=setRef.has(k);
      cb.addEventListener('change',()=>{ cb.checked?setRef.add(k):setRef.delete(k); });
      const span=document.createElement('span'); span.textContent=k;
      lbl.appendChild(cb); lbl.appendChild(span); return lbl;
    };
    keys.forEach(k=>container.appendChild(mk(k)));
  }

  function buildTable(rows, cols){
    resultsBody.innerHTML=''; theadRow.innerHTML='';
    if (!rows.length){ resultsTable.style.display='none'; return; }
    cols.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; theadRow.appendChild(th); });
    const frag=document.createDocumentFragment();
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      tr.innerHTML=cols.map(c=>`<td>${esc(r[c])}</td>`).join('');
      frag.appendChild(tr);
    });
    resultsBody.appendChild(frag); resultsTable.style.display='';
  }
  const toCsv=(rows,cols)=>[cols.join(','),...rows.map(r=>cols.map(c=>{const s=r[c]==null?'':String(r[c]);return /[",\r\n]/.test(s)?'"'+s.replace(/"/g,'""')+'"':s;}).join(','))].join('\r\n');

  // ---- Load JSON
  function load(text){
    root=JSON.parse(text);
    entries = scanFields(root);
    filteredEntries = entries;
    renderFieldList();
    setStatus(`Found ${entries.length.toLocaleString()} fields. Pick a field, choose row mode, then outputs.`, 'ok');
    enableRun();
  }

  // ---- Events
  fileInput.addEventListener('change', async e=>{
    const f=e.target.files?.[0]; if(!f) return;
    try{ const t=await f.text(); jsonText.value=t; load(t);}catch(err){ setStatus('Failed to read file: '+String(err),'err'); }
  });
  jsonText.addEventListener('blur', ()=>{ try{ const t=(jsonText.value||'').trim(); if(!t) return; load(t);}catch(_){}});

  clearBtn.addEventListener('click', ()=>{
    root=null; jsonText.value=''; fileInput.value='';
    entries=[]; filteredEntries=[]; fieldList.innerHTML=''; fieldSearch.value=''; showPaths.checked=false;
    selectedEntry=null; modeMatch.checked=false; modeParent.checked=false;
    selectedRowFields=new Set(); selectedMatchFields=new Set();
    rowFieldGrid.innerHTML=''; matchFieldGrid.innerHTML='';
    matchBlock.style.display=''; // reset
    resultsBody.innerHTML=''; theadRow.innerHTML=''; resultsTable.style.display='none';
    setDownloads(false); setStatus('');
    enableRun();
  });

  fieldSearch.addEventListener('input', ()=>{
    const q=fieldSearch.value.toLowerCase().trim();
    filteredEntries = !q ? entries : entries.filter(e=> e.chainLabel.toLowerCase().includes(q));
    renderFieldList();
  });
  showPaths.addEventListener('change', renderFieldList);

  fieldList.addEventListener('change', ()=>{
    selectedEntry = entries.find(e=> e.path===fieldList.value);
    if (!selectedEntry) return;

    // Determine collections
    const holderColl = selectedEntry.holderColl; // e.g. $.users[].role_members[]
    const parentColl = selectedEntry.parentColl; // e.g. $.users[]
    const sameLevel = holderColl === parentColl;

    // Build field sets by scanning the ENTIRE collections (not just matches)
    const parentObjs = collectAtCollection(parentColl);
    const holderObjs = collectAtCollection(holderColl);

    const rowKeys   = scalarKeysOf(parentObjs);
    const matchKeys = sameLevel ? [] : scalarKeysOf(holderObjs);

    // Reset selections and render chips
    selectedRowFields = new Set();
    selectedMatchFields = new Set();

    renderChips(rowFieldGrid, rowKeys, selectedRowFields);

    if (matchKeys.length){
      matchBlock.style.display='';
      renderChips(matchFieldGrid, matchKeys, selectedMatchFields);
    } else {
      matchBlock.style.display='none';
      matchFieldGrid.innerHTML='';
    }

    enableRun();
  });

  [modeMatch,modeParent].forEach(el=>el.addEventListener('change', enableRun));

  rowAll.addEventListener('click', ()=>{
    const keys=[...rowFieldGrid.querySelectorAll('label.chip span')].map(s=>s.textContent);
    selectedRowFields = new Set(keys); renderChips(rowFieldGrid, keys, selectedRowFields);
  });
  rowNone.addEventListener('click', ()=>{ selectedRowFields=new Set(); renderChips(rowFieldGrid, [], selectedRowFields); });

  matchAll.addEventListener('click', ()=>{
    const keys=[...matchFieldGrid.querySelectorAll('label.chip span')].map(s=>s.textContent);
    selectedMatchFields = new Set(keys); renderChips(matchFieldGrid, keys, selectedMatchFields);
  });
  matchNone.addEventListener('click', ()=>{ selectedMatchFields=new Set(); renderChips(matchFieldGrid, [], selectedMatchFields); });

  valuesInput.addEventListener('input', enableRun);
  [caseInsensitive, exactMatch].forEach(e=>e.addEventListener('change', enableRun));

  runBtn.addEventListener('click', ()=>{
    if (!root || !selectedEntry) return;

    const allowed = parseVals(valuesInput.value, caseInsensitive.checked);
    const ci=caseInsensitive.checked, exact=exactMatch.checked;

    // Resolve all matches of the selected field
    const matches = (function resolveMatches(fieldPath){
      const tks=tokensOf(fieldPath); const res=[];
      function recur(node, idx, listStack, objStack){
        if (idx>=tks.length) return;
        const tok=tks[idx];
        if (tok==='$'||tok==='$.'){recur(node, idx+1, listStack, objStack); return;}
        const coll=isColl(tok), key=base(tok);
        if (coll){
          const seq=node?.[key];
          const items = Array.isArray(seq)? seq : (seq && typeof seq==='object'? Object.values(seq) : []);
          for(const el of items){
            if (el && typeof el==='object') recur(el, idx+1, listStack.concat([{path:tks.slice(0,idx+1).join('.'), name:key, obj:el}]), objStack);
          }
        } else {
          if (idx===tks.length-1){
            const holder=node; const v=holder?.[key];
            if (v!==undefined && (typeof v!=='object' || v===null)) res.push({ value:v, holder, listStack });
          } else {
            const nxt=node?.[key];
            if (nxt && typeof nxt==='object') recur(nxt, idx+1, listStack, objStack.concat([{path:tks.slice(0,idx+1).join('.'), name:key, obj:nxt}]));
          }
        }
      }
      recur(root,0,[],[]);
      return res;
    })(selectedEntry.path).filter(m=> matchAllowed(allowed, m.value, {ci,exact}));

    // Build rows
    const perMatch = modeMatch.checked;
    const rows=[]; const colsSet=new Set();
    const holderName = (function(){ const t=tokensOf(selectedEntry.holderColl); return base(t[t.length-1]||'match'); })();
    const prefix = holderName ? holderName + '_' : 'match_';

    function nearestParent(m){ const ls=m.listStack; return ls.length? ls[ls.length-1].obj : m.holder; }

    if (perMatch){
      for(const m of matches){
        const parent = nearestParent(m);
        const out={};
        // row fields from parent
        for(const k of selectedRowFields){ out[k]= parent?.[k] ?? ''; colsSet.add(k); }
        // matched fields from holder
        for(const k of selectedMatchFields){ out[prefix+k]= m.holder?.[k] ?? ''; colsSet.add(prefix+k); }
        // always include filter value
        out[prefix+'filter_value'] = String(m.value); colsSet.add(prefix+'filter_value');
        rows.push(out);
      }
      const uniqParents=new Set(matches.map(nearestParent)).size;
      const uniqVals=new Set(matches.map(m=>String(m.value))).size;
      setStatus(`Rows: ${rows.length.toLocaleString()} • Unique parents: ${uniqParents.toLocaleString()} • Unique filter values: ${uniqVals.toLocaleString()}`, 'ok');
    } else {
      // Group by parent
      const groups=new Map();
      for(const m of matches){
        const p=nearestParent(m);
        if (!groups.has(p)) groups.set(p, []);
        groups.get(p).push(m);
      }
      for(const [parent, ms] of groups){
        const out={};
        for(const k of selectedRowFields){ out[k]= parent?.[k] ?? ''; colsSet.add(k); }
        // aggregate matched fields or at least the filter value list
        if (selectedMatchFields.size){
          const rendered = ms.map(mm=>{
            const bits=[]; for(const k of selectedMatchFields){ const v=mm.holder?.[k]; if (v!=null) bits.push(`${k}:${v}`); }
            return bits.join(', ');
          }).filter(Boolean).join('; ');
          out['matches'] = rendered; colsSet.add('matches');
        } else {
          out['matches'] = ms.map(mm=>String(mm.value)).join('; '); colsSet.add('matches');
        }
        rows.push(out);
      }
      setStatus(`Rows: ${rows.length.toLocaleString()}`, 'ok');
    }

    const cols=[...colsSet];
    lastRows=rows; lastCols=cols; buildTable(rows, cols); setDownloads(rows.length>0);
  });

  downloadJsonBtn.addEventListener('click', ()=>{
    if (!lastRows.length) return;
    const blob=new Blob([JSON.stringify(lastRows,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='filtered-output.json';
    document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
  });
  downloadCsvBtn.addEventListener('click', ()=>{
    if (!lastRows.length) return;
    const csv = [lastCols.join(','), ...lastRows.map(r=> lastCols.map(c=>{const s=r[c]==null?'':String(r[c]); return /[",\r\n]/.test(s)?'"'+s.replace(/"/g,'""')+'"':s;}).join(','))].join('\r\n');
    const blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='filtered-output.csv';
    document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
  });
  copyBtn.addEventListener('click', async()=>{
    if (!lastRows.length) return;
    try{ await navigator.clipboard.writeText(JSON.stringify(lastRows,null,2)); setStatus('Copied JSON to clipboard.','ok'); }
    catch(e){ setStatus('Copy failed: '+e.message,'err'); }
  });

})();
</script>
</body>
</html>
